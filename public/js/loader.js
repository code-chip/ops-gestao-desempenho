(function () {var a = "'do tipo", k = "SCRIPT", n = "array", p = "função", q = "google.charts.load", t = "hasOwnProperty", u = "número", v = "objeto", w = "pré-45", x = "propertyIsEnumerable", y = "string", z = "texto / javascript", A = "toLocaleString"; função B () {retorno function (b) {return b}} função C () {função return () {}} função D (b) {função return () {return this [b]}} função E (b) {função return () { return b}} var F, H = H || {}; H.scope = {}; H.Li = função (b) {var c = 0; função de retorno () {retorno c <b.length? {feito :! 1, valor: b [c ++]}: {feito:! 0}}}; H.Ki = função (b) {retorno {próximo: H.Li (b)}};
H.Rd = função (b) {var c = "indefinido"! = Typeof Symbol && Symbol.iterator && b [Symbol.iterator]; retorno c? C.call (b): H.Ki (b)}; H.Ji = função (b) {para (var c, d = [];! (c = b.next ()). done;) d.push (c.value); retorno d}; H.Ii = function (b) { return b instanceof Array? b: H.Ji (H.Rd (b))}; H.Tq = função (b, c, d) {b instância da String && (b = String (b)); para (var e = b.length, f = 0; f <e; f ++) {var g = b [f]; se (c.call (d, g, f, b)) retornar {ck: f, Ol: g}} voltar {ck: -1, Ol: void 0}}; H.zh =! 1; H.gm =! 1; H.hm =! 1; H.Jo =! 1;
H.defineProperty = H.zh || typeof Object.defineProperties == p? Object.defineProperty: function (b, c, d) {b! = Array.prototype && b! = Object.prototype && (b [c] = d.value )}; H.Kj = função (b) {return "undefined"! = Janela type && window === b? B: "undefined"! = Tipo global && null! = Global? Global: b}; H.global = H.Kj (isto);
H.Vk = funç˜ao (b, c) {se (c) {var d = H.global; b = b.split ("."); Para (var e = 0; e <b.length-1; e ++ ) {var f = b [e]; f in d || (d [f] = {}); d = d [f]} b = b [comprimento-1]; e = d [b]; c = c (e); c! = e && null! = c && H.defineProperty (d, b, {configurável:! 0, gravável:! 0, valor: c})}}; H.hq = função (b, c, d) {if (null == b) lançar novo TypeError ("O valor 'this' para String.prototype." + d + "não deve ser nulo ou indefinido"); if (c instanceof RegExp) lançar novo TypeError ("First argumento para String.prototype. "+ d +" não deve ser uma expressão regular "); return b +" "}; H.Xh =! 1;
H.Vk ("Promise", função (b) {função c (b) {this.ca = g.Aa; this.ma = void 0; this.vb = []; var c = this.md (); tente {b (c.resolve, c.reject)} catch (r) {c.reject (r)}} função d () {this.La = null} function e (b) {retorno b instanceof c? b: novo c (função (c) {c (b)})} se (b &&! H.Xh) retornar b; d.prototype.cf = function (b) {se (null == this.La) {this.La = []; var c = this; this.df (function () {c.wj ()})} this.La.push (b)}; var f = H.global.setTimeout; d.prototype.df = function (b) {f (b, 0)}; d.prototype.wj = function () {para (; this.La && this.La.length;) {var b = this.La; this.La =
[]; para (var c = 0; c <b.length; ++ c) {var d = b [c]; b [c] = nulo; tente {d ()} capturar (G) {this.Pi (G)}}} this.La = null}; d.prototype.Pi = function (b) {this.df (função () {lance b;})}; var g = {Aa: 0, Ka: 1 , oa: 2}; c.prototype.md = function () {função b (b) {função de retorno (e) {d || (d =! 0, b.call (c, e))}} var c = this, d =! 1; return {resolver: b (isto. $ k), rejeitar: b (this.Zd)}}; c.prototype. $ k = function (b) {if (b === isto ) this.Zd (new TypeError ("Um Promise não pode resolver para si mesmo")); else if (b instanceof c) this.rl (b); senão {a: switch (typeof b) {caso v: var d = null ! = b; quebra a;
caso p: d =! 0; quebra a; padrão: d =! 1} d? this.Zk (b): this.Ef (b)}}; c.prototype.Zk = function (b) {var c = void 0; tente {c = b.then} catch (r) {this.Zd (r); retorno} typeof c == p? this.sl (c, b): this.Ef (b)}; c. prototype.Zd = função (b) {this.dh (g.oa, b)}; c.prototype.Ef = função (b) {this.dh (g.Ka, b)}; c.prototype.dh = função (b, c) {se (this.ca! = g.Aa) erro de lançamento ("Não é possível resolver (" + b + "," + c + "): Promessa já resolvida no estado" + this.ca); this. ca = b; this.ma = c; this.yj ()}; c.prototype.yj = function () {if (null! = this.vb) {para (var b = 0; b <this.vb. comprimento; ++ b) h.cf (this.vb [b]);
this.vb = null}}; var h = new d; c.prototype.rl = function (b) {var c = this.md (); b.hc (c.resolve, c.reject)}; c. prototype.sl = function (b, c) {var d = this.md (); tente {b.call (c, d.resolve, d.reject)} capturar (G) {d.reject (G)}} c.prototype.then = function (b, d) {função e (b, c) {retorno typeof b == p? função (c) {try {f (b (c))} captura (aa) {g (aa)}}: c} var f, g, h = novo c (função (b, c) {f = b; g = c}); this.hc (e (b, f), e (d, g)); return h}; c.prototype ["catch"] = function (b) {retornar this.then (void 0, b)}; c.prototype.hc = funç˜ao (b, c) {funç˜ao d ( ) {switch (e.ca) {caso g.Ka: b (e.ma);
case g.oa: c (e.ma); break; padrão: throw Error ("Estado inesperado:" + e.ca);}} var e = this; null == this.vb? h.cf ( d): this.vb.push (d)}; c.resolve = e; c.reject = function (b) {retornar novo c (função (c, d) {d (b)})}; = function (b) {return new c (função (c, d) {para (var f = H.Rd (b), g = f.next () ;! g.done; g = f.next ()) e (g.value) .hc (c, d)})}; c.all = function (b) {var d = H.Rd (b), f = d.next (); retorno f.done e ([]): novo c (função (b, c) {função g (c) {função de retorno (d) {h [c] = d; l -; 0 == l && b (h)}} var h = [], l = 0; faça h.push (void 0), l ++, e (f.value) .hc (g (h.length-
1), c), f = d.next (); while (! F.done)})}; return c}); var I = I || {}; I.global = isto; IX = função (b ) {return void 0! == b}; IO = function (b) {retorno typeof b == y}; I.fk = function (b) {retorno "booleano" == typeof b}; I.Ub = função (b) {return typeof b == u}; I.rd = função (b, c, d) {b = b.split ("."); d = d || I.global; b [0] in d || "indefinido" == typeof d.execScript || d.execScript ("var" + b [0]); para (var e; b.length && (e = b.shift ());)! b. length && I.X (c)? d [e] = c: d = d [e] && d [e]! == Object.prototype [e]? d [e]: d [e] = {}}; define = função (b, c) {I.rd (b, c); retorno c}; i. $ =! 0;
IK = "en"; I.ed =! 0; I.ui =! 1; I.Sh =! I. $; I.Xm =! 1; I.Zs = funo (b) {if (I.yg ()) erro de lançamento ("goog.provide não pode ser usado dentro de um módulo."); I.nf (b)}; I.nf = função (b, c) {I.rd (b, c)}; .eg = function () {null === I.nd && (I.nd = I.Oj ()); retorno I.nd}; I.ei = / ^ [\ w + / _-] + [=] { 0,2} $ /; I.nd = null; I.Oj = function () {var b = I.global.document; retorno (b = b.querySelector && b.querySelector ("script [nonce]")) && ( b = b.nonce || b.getAttribute ("nonce")) && I.ei.test (b)? b: ""}; I.Bi = / ^ [a-zA-Z _ $] [a-zA- Z0-9 ._ $] * $ /;
I.Bc = function (b) {se (! IO (b) ||! B || -1 == b.search (I.Bi)) Erro de lançamento ("Identificador de módulo inválido"); if (! I. xg ()) throw Erro ("Módulo" + b + "foi carregado incorretamente. Note que os módulos não podem ser carregados como scripts normais. Eles requerem algum tipo de etapa de pré-processamento. É provável que você esteja tentando carregar um módulo por meio de um script ou como parte de um pacote concatenado sem reescrever o módulo. Para obter mais informações, consulte: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative- to-goog.provide. ");
if (I.ja.Vb) erro de lançamento ("goog.module só pode ser chamado uma vez por módulo."); I.ja.Vb = b}; I.Bc.get = E (nulo); I.Bc. vr = E (nulo); I.Bb = {De: "es6", cd: "goog"}; I.ja = nulo; I.yg = função () {devolução I.xg () || I.lk ()}; I.xg = function () {return !! I.ja && I.ja.type == I.Bb.cd}; I.lk = function () {if (I.ja && I.ja.type == I.Bb.De) retornar! 0; var b = I.global. $ Jscomp; retorno b? Tipo de b.wd! = P?! 1: !! b.wd () :! 1}; I.Bc. od = function () {I.ja.od =! 0};
I.mj = function (b) {se (I.ja) I.ja.Vb = b; senão {var c = I.global. $ Jscomp; if (! C || tipo de c.wd! = P) Erro ('Módulo com espaço de nomes "' + b + '" foi carregado incorretamente.'); C = c.Xk (c.wd ()); I.Kg [b] = {zj: c, tipo: I.Bb .De, Sk: b}}}; I.Bc.Gq = I.mj; I.Tt = função (b) {se (I.Sh) lançar b = b || "", Erro ("Importando teste- somente código em ambiente não-debug "+ (b?": "+ b:". "));}; I.Zq = C (); I.ab = função (b) {b = b.split (" . "); para (var c = I.global, d = 0; d <b.length; d ++) se (c = c [b [d]] ,! I.eb (c)) retornar null; };
I.Gr = funç˜ao (b, c) {c = c || I.global; para (var d em b) c [d] = b [d]}; I.tp = C (); I.xu = ! 1; I.Ym =! 0; I.Ik = função (b) {I.global.console && I.global.console.error (b)}; I.Xk = C (); I.lt = function () {return {}}; I.Si = ""; I.fb = C (); I.sp = function () {throw Error ("método abstrato não implementado");}; I.up = function (b) { b.Kd = void 0; b.ur = function () {se (b.Kd) retorna b.Kd; I. $ && (I.qg [I.qg.length] = b); retorno b.Kd = novo b}}; I.qg = []; I.Un =! 0; I.pi = I. $; I.Kg = {}; I.Jm =! 1; I.gp = "detectar"; .fm =! 1; I.hp = ""; I.wi = "transpile.js"; I.Id = nulo;
I.Ml = function () {if (null == I.Id) {try {var b =! Eval ('"usar estrito"; vamos x = 1; função f () {retornar tipo de x;}; f ( ) == "number"; ')} catch (c) {b =! 1} I.Id = b} retorno I.Id}; I.Sl = function (b) {retorno "(function () {" + b + "\ n;}) (); \ n"};
I.Cs = function (b) {var = Euja; try {I.ja = {Vb: "", od:! 1, tipo: I.Bb.cd}; se (I.Ca (b) ) var d = b.call (void 0, {}); senão se (IO (b)) I.Ml () && (b = I.Sl (b)), d = I.Fk.call (void 0 , b); caso contrário, lançar Erro ("Definição de módulo inválida"); var e = I.ja.Vb; if (IO (e) && e) I.ja.od? I.nf (e, d): I.pi && Object .seal && typeof d == v && null! = d && Objeto.seal (d), I.Kg [e] = {zj: d, tipo: I.Bb.cd, Sk: I.ja.Vb}; else throw Error ('Inválido' nome do módulo "'+ e +'" ');} finalmente {I.ja = c}}; I.Fk = função (b) {eval (b); retorno {}};
I.Ns = função (b) {b = b.split ("/"); para (var c = 0; c <b.length;) "." == b [c] b.splice (c, 1): c && ".." == b [c] && b [c-1] && ".."! = B [c-1] b.splice (- c, 2): c ++; retorno b. join ("/")}; I.Dk = function (b) {se (I.global.Lh) retorna I.global.Lh (b); tente {var c = novo I.global.XMLHttpRequest; c.open ("get", b,! 1); c.send (); return 0 == c.status || 200 == c.status? c.responseText: null} captura (d) {retorno nulo}};
I.ou = função (b, c, d) {var e = I.global. $ Jscomp; e || (I.global. $ Jscomp = e = {}); var f = e.ke; if (! f) {var = I.Si + I.wi, h = I.Dk (g); if (h) {(função () {eval (h + "\ n // # sourceURL =" + g)}) .call (I.global); if (I.global. $ gwtExport && I.global. $ gwtExport. $ jscomp &&! I.global. $ gwtExport. $ jscomp.transpile) erro de lançamento ('O transpilador não exportou corretamente o transpile "método. $ gwtExport: '+ JSON.stringify (I.global. $ gwtExport)); I.global. $ jscomp.ke = I.global. $ gwtExport. $ jscomp.transpile; e = I.global. $ jscomp ; f = e.ke}} if (! f) {var l = "requer transpilaç˜ao mas nenhum transpilador foi encontrado.";
l + = 'Por favor, adicione "// javascript / closure: transpiler" como dependência de dados para garantir que está incluído.'; f = e.ke = função (b, c) {I.Ik (c + l); retorno b }} return f (b, c, d)};
I.da = função (b) {var c = tipo de b; if (c == v) if (b) {se (instância de Array) retornar n; if (b instanceof Object) retorna c; var d = Object. prototype.toString.call (b); if ("[object Window]" == d) retornar v; if ("[Array do objeto]" == d || typeof b.length == u && "indefinido"! = typeof b.splice && "undefined"! = typeof b.propertyIsEnumerable &&! b.propertyIsEnumerable ("splice")) return n; if ("[objeto Função]" == d || "indefinido"! = typeof b.call && "undefined" ! = typeof b.propertyIsEnumerable &&! b.propertyIsEnumerable ("call")) return p mais return "null";
else if (c == p && "indefinido" == typeof b.call) retorno v; retorno c}; I.ns = função (b) {retorno nulo === b}; I.eb = função (b) { return null! = b}; I.isArray = função (b) {retorno I.da (b) == n}; I.Pb = função (b) {var = Ida (b); retorno c = = n || c == v && typeof b.length == u}; I.Yr = função (b) {retorno I.la (b) && tipoof b.getFullYear == p}; I.Ca = função (b) { retorno I.da (b) == p}; I.la = função (b) {var c = tipo de b; retorno c == v && nulo! = b || c == p}; I.gg = função (b ) {return b [I.Va] || (b [I.Va] = ++ I.El)}; I.Jr = function (b) {retorno !! b [I.Va]};
I.Wk = function (b) {null! == b && "removeAttribute" em b && b.removeAttribute (I.Va); tente {delete b [I.Va]} capturar (c) {}}; I.Va = " closure_uid _ "+ (1E9 * Math.random () >>> 0); I.El = 0; I.tr = I.gg; I.gt = I.Wk; I.cj = função (b) {var = Lda (b); se (c == v || c == n) {if (tipo de b.clone === p) retorna b.clone (); c = c == n? []: {}; para (var d em b) c [d] = I.cj (b [d]); retorno c} retorno b}; I.Ui = função (b, c, d) {retorno b.call. apply (b.bind, argumentos)};
I.Ti = função (b, c, d) {se (! B) ataca Erro (); if (2 <argumentos.length) {var e = Array.prototype.slice.call (argumentos, 2); função de retorno () {var d = Array.prototype.slice.call (argumentos); Array.prototype.unshift.apply (d, e); retorno b.apply (c, d)}} função return () {return b.apply (c, argumentos)}}; I.bind = function (b, c, d) {iBind = Function.prototype.bind && - 1! = Function.prototype.bind.toString (). indexOf ("código nativo" ) I.Ii: I.Ti; return I.bind.apply (nulo, argumentos)};
I.gb = function (b, c) {var d = Array.prototype.slice.call (argumentos, 1); função de retorno () {var c = d.slice (); c.push.apply (c, argumentos ); return b.apply (isto, c)}}; I.Is = função (b, c) {para (var d em c) b [d] = c [d]}; I.now = I.ed && Date .now || function () {return + nova data};
I.Fr = function (b) {se (I.global.execScript) I.global.execScript (b, "JavaScript"); senão if (I.global.eval) {if (null == I.oc) { try {I.global.eval ("var _evalTest_ = 1;")} catch (e) {} se ("indefinido"! = tipo de I.global._evalTest _) {try {delete I.global._evalTest_} catch (e ) {} I.oc =! 0} mais I.oc =! 1} se (I.oc) I.global.eval (b); em alternativa {var c = I.global.document, d = c.createElement ( k); d.type = z; d.defer =! 1; d.appendChild (c.createTextNode (b)); c.head.appendChild (d); c.head.removeChild (d)}} else throw Erro ("goog.globalEval não disponível");};
I.oc = nulo; I.rr = função (b, c) {função d (b) {b = b.split ("-"); para (var c = [], d = 0; d <b. length; d ++) c.push (e (b [d])); retorno c.join ("-")} function e (b) {retorno I.sf [b] || b} if ("." = = String (b) .charAt (0)) Erro de lançamento ('className passado em goog.getCssName não deve iniciar com ".". Você passou:' + b); var f = I.sf? "BY_WHOLE" == I .lj? e: d: B (); b = c? b + "-" + f (c): f (b); retorno I.global.Kh?I.global.Kh(b):b};I .Bt = função (b, c) {I.sf = b; I.lj = c};
I.wr = função (b, c) {c && (b = b.replace (/ \ {\ $ ([^}] +)} / g, função (b, e) {retorno nulo! = C && e em c? c [e]: b})); retorno b}; I.xr = B (); I.pc = função (b, c) {I.rd (b, c, void 0)}; I.Sq = funo (b, c, d) {b [c] = d}; I.bb = funo (b, c) {funo d ​​() {} d.protipo = c.protipo; b.Qc = c.protipo; b.prototipo = novo d; b.prototipo.construtor = b; b.Ri = função (b, d, g) {para (var e = Matriz (argumentos.length-2), f = 2; f <argumentos. comprimento; f ++) e [f-2] = argumentos [f]; retorno c.prototipo [d] .apply (b, e)}};
I.Ri = function (b, c, d) {var e = argumentos.callee.caller; if (I.ui || I. $ &&! E) throw Erro ("arguments.caller não definido. Goog.base ( ) não pode ser usado com código de modo estrito.Veja http://www.ecma-international.org/ecma-262/5.1/#sec-C");if("undefined"!==typeof e.Qc) {para (var f = Matriz (arguments.length-1), g = 1; g <argumentos.length; g ++) f [g-1] = argumentos [g]; return e.Qc.constructor.apply (b, f) } if (typeof c! = y && "símbolo"! = typeof c) throw Error ("nomes de métodos fornecidos para goog.base deve ser uma string ou um símbolo"); f = Array (arguments.length-
2); para (g = 2; g <argumentos.length; g ++) f [g-2] = argumentos [g]; g =! 1; para (var h = b.construtor; h; h = h.Qc && h .Qc.constructor) if (h.prototype [c] === e) g =! 0; caso contrário, se (g) retornar h.prototype [c] .apply (b, f); if (b [c] = == e) return b.constructor.prototype [c] .apply (b, f); throw Erro ("goog.base chamado de um método de um nome para um método de um nome diferente");}; I.scope = function (b) {if (I.yg ()) erro de lançamento ("goog.scope não é suportado dentro de um módulo."); b.call (I.global)};
I.ra = function (b, c) {var d = c. Construtor, e = c.wl; d && d! = Object.prototype.constructor || (d = função () {throw Error ("não é possível instanciar uma interface ( nenhum construtor definido). ");}); d = I.ra.hj (d, b); b && I.bb (d, b); excluir c.construtor; excluir c.wl; I.ra.bf (d .prototype, c); null! = e && (e instanceof Function? e (d): I.ra.bf (d, e)); return d}; I.ra.oi = I. $;
I.ra.hj = função (b, c) {função d () {var c = b.apply (isto, argumentos) || isto; c [I.Va] = c [I.Va]; === d && &&& Object.seal instanceof Function && Object.seal (c); return c} if (! I.ra.oi) return b; var e =! I.ra.xk (c); return d}; I.ra. xk = function (b) {retorno b &&.prototype && b.prototype [I.yi]}; I.ra.Ne = ["construtor", t, "isPrototypeOf", x, A, "toString", "valueOf"];
I.ra.bf = function (b, c) {para (var d em c) Object.prototype.hasOwnProperty.call (c, d) && (b [d] = c [d]); para (var e = 0; e <I.ra.Ne.length; e ++) d = I.ra.Ne [e], Object.prototype.hasOwnProperty.call (c, d) && (b [d] = c [d])} Ihu = C (); I.yi = "goog_defineClass_legacy_unsealable"; I.debug = {}; I.debug.Error = função (b) {if (Error.captureStackTrace) Error.captureStackTrace (isto, I.debug .Error); else {var c = Erro (). Stack; c && (this.stack = c)} b && (this.message = Cadeia (b))}; I.bb (I.debug.Error, Erro); I.debug.Error.prototype.name = "CustomError"; Ia = {}; Iaga = {Ja: 1, im: 2, ec: 3, xm: 4, $ m: 5, Zm: 6, vo: 7 Em: 8, $ c: 9, Rm: 10, Th: 11, jo: 12}; Io = {}; Iona = I. $; IoZb = função (b, c) {I.debug.Error.call (isto, Ioyl (b, c))}; I.bb (IoZb, I.debug.Error); IoZb.prototype.name = "AssertionError"; IoPh = função (b) {lance b;}; Iopd = IoPh Ioyl = função (b, c) {b = b.split ("% s"); para (var d = "", e = b.length-1, f = 0; f <e; f ++) d + = b [f] + (f <c.length? c [ f]: "% s"); retorno d + b [e]}; IoBa = função (b, c, d, e) {var f = "Asserção falhou"; if (d) {f + = ":" + d; var g = e} mais b && (f + = ":" + b, g = c); b = novo IoZb ("" + f, g || []); Iopd (b)}; IoFt = funo ( b) {Iona && (Iopd = b)};
Ioassert = função (b, c, d) {Iona &&! B && I.o.Ba ("", nulo, c, Array.prototype.slice.call (argumentos, 2)); retorno b}; Ioia = função (b, c) {Iona && I.o.pd (novo IoZb ("Falha" + (b? ":" + b: ""), Array.prototype.slice.call (arguments, 1)))}; IoTp = function (b , c, d) {Iona &&! I.Ub (b) && I.o.Ba ("Número esperado, mas obtém% s:% s.", [I.da (b), b], c, Array.prototype. slice.call (argumentos, 2)); return b};
IoWp = função (b, c, d) {Iona &&! IO (b) && I.o.Ba ("Esperado cadeia mas obteve% s:% s.", [I.da (b), b], c, Matriz .prototype.slice.call (arguments, 2)); return b}; IoDp = function (b, c, d) {Iona &&! I.Ca (b) && I.o.Ba ("Função esperada, mas obteve% s: % s. ", [I.da (b), b], c, Array.prototype.slice.call (argumentos, 2)); retorno b}; IoUp = função (b, c, d) {Iona &&! I .la (b) && I.o.Ba ("Objeto esperado, mas obteve% s:% s.", [I.da (b), b], c, Array.prototype.slice.call (argumentos, 2)) ; retorno b};
Iozp = function (b, c, d) {Iona &&! I.isArray (b) && I.o.Ba ("Matriz esperada, mas obteve% s:% s.", [I.da (b), b], c , Array.prototype.slice.call (arguments, 2)); return b}; IoAp = function (b, c, d) {Iona &&! I.fk (b) && I.o.Ba ("Esperado booleano mas tem% s:% s. ", [I.da (b), b], c, Array.prototype.slice.call (argumentos, 2)); retorno b}; IoBp = função (b, c, d) {! Iona || I.la (b) && b.nodeType == Iaga.Ja || IoBa ("Elemento Esperado, mas obteve% s:% s.", [I.da (b), b], c, Array.prototype .slice.call (argumentos, 2)); return b};
IoEp = function (b, c, d, e) {! Iona || b instanceof c || IoBa ("Instância esperada de% s mas obtém% s.", [Iofg (c), Iofg (b)], d, Array.prototype.slice.call (arguments, 3)); return b}; IoCp = function (b, c, d) {! Iona || typeof b == u && isFinite (b) || IoBa ("Esperado% s para seja um número finito, mas não é. ", [b], c, Array.prototype.slice.call (arguments, 2)); return b}; IoVp = function () {for (var b no Object.prototype) Ioia (b + "não deve ser enumerável em Object.prototype.")};
Iofg = function (b) {retorno b instanceof Function? B.displayName || b.name || "nome do tipo desconhecido": b instanceof Object? B.constructor.displayName || b.constructor.name || Object.prototype. toString.call (b): null === b? "null": typeof b}; Ij = {}; I.Ga = I.ed; IjDa =! 1; IjUk = funo (b) {retorno b [b .length-1]}; Ijys = IjUk; IjindexOf = I.Ga && (IjDa || Array.prototype.indexOf)? function (b, c, d) {retornar Array.prototype.indexOf.call (b, c, d )}: function (b, c, d) {d = null = = d? 0: 0> d? Math.max (0, b.length + d): d; se (IO (b)) retornar IO ( c) && 1 == c.length? b.indexOf (c, d): - 1; para (; d <b.length; d ++) if (d em b && b [d] === c) retorno d; 1};
IjlastIndexOf = I.Ga && (IjDa || Array.prototype.lastIndexOf)? Function (b, c, d) {retornar Array.prototype.lastIndexOf.call (b, c, null == d? B.length-1: d )}: function (b, c, d) {d = null = = d? b.length-1: d; 0> d && (d = Math.max (0, b.length + d)); (b)) retornar IO (c) && 1 == c.length? b.lastIndexOf (c, d): - 1, para (; 0 <= d; d -) se (d em b && b [d] == = c) retorno d; retorno-1};
IjforEach = I.Ga && (IjDa || Array.prototype.forEach)? Function (b, c, d) {array.prototype.forEach.call (b, c, d)}: function (b, c, d) { para (var e = b.length, f = IO (b)? b.split (""): b, g = 0; g <e; g ++) g em f &&.c.call (d, f [g], g bj IjDf = função (b, c) {para (var d = IO (b) b.split (""): b, e = b.length-1; 0 <= e; e em d & c.call (void 0, d [e], e, b)};
Ijfilter = I.Ga && (IjDa || Array.prototype.filter)? Função (b, c, d) {retornar Array.prototype.filter.call (b, c, d)}: função (b, c, d) {para (var e = b.length, f = [], g = 0, h = IO (b)? b.split (""): b, l = 0; l <e; l ++) se (l em h) {var m = h [l]; c.call (d, m, l, b) && (f [g ++] = m)} retorno f}; Ijmap = I.Ga && (IjDa || Array.prototype. map)? function (b, c, d) {retornar Array.prototype.map.call (b, c, d)}: function (b, c, d) {para (var e = b.length, f = Array (e), g = IO (b)? b.split (""): b, h = 0; h <e; h ++) h em g && (f [h] = c.call (d, g [h] , h, b)); retorno f};
Ijreduce = I.Ga && (IjDa || Array.prototype.reduce)? Function (b, c, d, e) {e && (c = I.bind (c, e)); retorno Array.prototype.reduce.call ( b, c, d)}: função (b, c, d, e) {var f = d; IjforEach (b, função (d, h) {f = c.call (e, f, d, h, b )}); return f}; IjreduceRight = I.Ga && (IjDa || Array.prototype.reduceRight)? function (b, c, d, e) {e && (c = I.bind (c, e)); Array.prototype.reduceRight.call (b, c, d)}: função (b, c, d, e) {var f = d; IjDf (b, função (d, h) {f = c.call (e , f, d, h, b)}); retorno f};
Ijsome = I.Ga && (IjDa || Array.prototype.some)? Function (b, c, d) {retornar Array.prototype.some.call (b, c, d)}: função (b, c, d) {para (var e = b.length, f = IO (b)? b.split (""): b, g = 0; g <e; g ++) if (g em f &&.c.call (d, f [g ], g, b)) return! 0; return! 1}; Ijevery = I.Ga && (IjDa || Array.prototype.every)? function (b, c, d) {retornar Array.prototype.every.call ( b, c, d)}: função (b, c, d) {para (var e = b.length, f = IO (b) b b.split (""): b, g = 0; g <e ; g ++) if (g em f &&! c.call (d, f [g], g, b)) retorno! 1; retorno! 0};
Icount = função (b, c, d) {var e = 0; Ij para cada uma (b, função (b, g, h) {c.call (d, b, g, h) & &; ++ e}, d); return e}; Ijfind = function (b, c, d) {c = IjfindIndex (b, c, d); retorno 0> c? null: IO (b)? b.charAt (c): b [c]} ; IjfindIndex = funç˜ao (b, c, d) {para (var e = b.length, f = IO (b)? B.split (""): b, g = 0; g <e; g ++) if ( g em f &&.c.call (d, f [g], g, b)) retorno g; retorno-1}; IjUq = função (b, c, d) {c = IjAj (b, c, d); retorno 0 > c? null: IO (b)? b.charAt (c): b [c]};
IjAj = função (b, c, d) {para (var e = IO (b)? B.split (""): b, f = b.length-1; 0 <= f; f -) if ( f in e && c.call (d, e [f], f, b)) retorno f; retorno-1}; Ijcontains = função (b, c) {retorno 0 <= IjindexOf (b, c)}; IjSb = função (b) {return 0 == b.length}; Ijclear = function (b) {if (! I.isArray (b)) para (var c = b.length-1; 0 <= c; c--) delete b [c]; b.length = 0}; IjNr = função (b, c) {Ijcontains (b, c) || ​​b.push (c)}; Ijmg = função (b, c, d) {Ijsplice (b, d, 0, c)}; IjPr = função (b, c, d) {I.gb (Ijsplice, b, d, 0) .apply (null, c)};
IjinsertBefore = function (b, c, d) {var e; 2 == argumentos.length || 0> (e = IjindexOf (b, d))? B.push (c): Ijmg (b, c, e) }; Ijremove = function (b, c) {c = IjindexOf (b, c); var d; (d = 0 <= c) && I.j.xb (b, c); retorno d}; Ijit = função ( b, c) {c = IjlastIndexOf (b, c); retorno 0 <= c? (Ijxb (b, c),! 0) :! 1}; Ijxb = função (b, c) {retorno 1 == Matriz .prototype.splice.call (b, c, 1) .length}; Ijht = funç˜ao (b, c, d) {c = IjfindIndex (b, c, d); retorno 0 <= c ((Ijxb (b, c), 0) :! 1};
Ijet = função (b, c, d) {var e = 0; IjDf (b, função (f, g) {c.call (d, f, g, b) & ij.xb (b, g) && e ++ }); return e}; Ijconcat = function (b) {return Array.prototype.concat.apply ([], argumentos)}; Ijjoin = function (b) {return Array.prototype.concat.apply ([], argumentos )}; Ijmh = function (b) {var = b.length; if (0 <c) {para (var d = Matriz (c), e = 0; e <c; e ++) d [e] = b [e]; return d} return []}; Ijclone = Ijmh;
Ijextend = function (b, c) {para (var d = 1; d <argumentos.length; d ++) {var e = argumentos [d]; se (I.Pb (e)) {var f = b.length | | 0, g = e.length || 0; b.length = f + g; para (var h = 0; h <g; h ++) b [f + h] = e [h]} mais b.push ( e)}}; Ijsplice = function (b, c, d, e) {retornar Array.prototype.splice.apply (b, Ijslice (argumentos, 1))}; Ijslice = function (b, c, d) {return 2> = arguments.length? Array.prototype.slice.call (b, c): Array.prototype.slice.call (b, c, d)};
Ijft = função (b, c, d) {função e (b) {retorno I.la (b)? "O" + I.gg (b): (tipo de b) .charAt (0) + b} c = c || b; d = d || e; para (var f = {}, g = 0, h = 0; h <comprimento_leve;) {var l = b [h ++], m = d (l) Object.prototype.hasOwnProperty.call (f, m) || (f [m] =! 0, c [g ++] = l)} c.length = g}; Ijef = funç˜ao (b, c, d) { return Ijff (b, d || IjOa,! 1, c)}; Ij $ p = function (b, c, d) {return Ijff (b, c, 0, void 0, d)}; (b, c, d, e, f) {para (var g = 0, h = b.length, l; g <h;) {var m = g + h >> 1; var r = dc. chamada (f, b [m], m, b): c (e, b [m]); 0 <r? g = m + 1: (h = m, l =! r)} retorno l? g: ~ g};
Ijsort = função (b, c) {b.sort (c || IjOa)}; Ijbu = função (b, c) {para (var d = Matriz (comprimento), e = 0; e <b.length ; e ++) d [e] = {índice: e, valor: b [e]}; var f = c || IjOa; Ijsort (d, função (b, c) {retorno f (b.valor, c.value ) || b.index-c.index}); para (e = 0; e <b.length; e ++) b [e] = d [e] .value}; Ijul = função (b, c, d) {var e = d || IjOa; Ijsort (b, função (b, d) {return e (c (b), c (d))})}; IjZt = função (b, c, d) {Ijul ( b, função (b) {retorno b [c]}, d)};
Ijts = função (b, c, d) {c = c || IjOa; para (var e = 1; e <b.length; e ++) {var f = c (b [e-1], b [e] ); if (0 <f || 0 == f && d) retorna! 1} return! 0}; IjKb = funç˜ao (b, c) {se (! I.Pb (b) ||! I.Pb (c) || b.length! = c.length) return! 1; para (var d = b.length, e = Ijnj, f = 0; f <d; f ++) if (! e (b [f], c [ f])) return! 1; return! 0}; Ijnq = function (b, c, d) {d = d || IjOa; para (var e = Math.min (comprimento_b, c.length), f = 0; f <e; f ++) {var g = d (b [f], c [f]); se (0! = G) retornará g} retorne IjOa (comprimento_b, c.length)}; IjOa = funo (b, c) {retorno b> c? 1: b <c? -1: 0};
IjRr = função (b, c) {retorno-IjOa (b, c)}; Ijnj = função (b, c) {retorno b === c}; IjYp = função (b, c, d) {d = Ijef (b, c, d); retorno 0> d? (Ijmg (b, c, - (d + 1)), 0) :! 1}; IjZp = funç˜ao (b, c, d) {c = Ijef (b, c, d); retorno 0 <= c Ijxb (b, c) :! 1}; Ijbq = funç˜ao (b, c, d) {para (var e = {}, f = 0; f < b.length; f ++) {var g = b [f], h = c.call (d, g, f, b); IX (h) && (e [h] || (e [h] = [] empurre (g)} retorne e}; Ijlu = função (b, c, d) {var e = {}; IjforEach (b, função (f, g) {e [c.call (d, f, g, b)] = f}); return e};
Ijat = função (b, c, d) {var e = [], f = 0, g = b; d = d || 1; void 0! == c && (f = b, g = c); 0> d * (gf)) return []; se (0 <d) para (b = f; b <g; b + = d) e.push (b); outro para (b = f; b> g; b + = d) e.push (b); return e}; Ijrepeat = função (b, c) {para (var d = [], e = 0; e <c; e ++) d [e] = b; d); Ijflatten = function (b) {para (var c = [], d = 0; d <argumentos.length; d ++) {var e = argumentos [d]; if (I.isArray (e)) para ( var f = 0; f <e.length; f + = 8192) para (var g = Ijflatten.apply (nulo, Ijslice (e, f, f + 8192)), h = 0; h <g.length; h ++) c.push (g [h]); caso contrário, c.push (e)} retorna c};
Ijrotate = função (b, c) {b.length && (c% = comprimento_B, 0 <c? Array.prototype.unshift.apply (b, b.splice (-c, c)): 0> c && Array.prototype .push.apply (b, b.splice (0, -c))); retorno b}; IjKs = função (b, c, d) {c = Array.prototype.splice.call (b, c, 1) ; Array.prototype.splice.call (b, d, 0, c [0])};
IjBu = function (b) {if (! Argumentos.length) return []; para argumentos (var c = [], d = argumentos [0] .length, e = 1; e <argumentos.length; e ++) [e ] .length <d && (d = argumentos [e] .comprimento); para (e = 0; e <d; e ++) {para (var f = [], g = 0; g <argumentos.length; g ++) f .push (argumentos [g] [e]); c.push (f)} return c}; IjYt = function (b, c) {c = c || Math.random; para (var d = b.length- 1; 0 <d; d -) {var = Math.floor (c () * (d + 1)), f = b [d]; b [d] = b [e]; b [e] = f}}; Ijsq = function (b, c) {var d = []; IjforEach (c, funo (c) {d.push (b [c])}); retorno d};
Ijpq = function (b, c, d) {retornar Ijconcat.apply ([], Ijmap (b, c, d))}; I.async = {}; I.async.ac = função (b, c, d ) {this.Ck = d; this.kj = b; this.Yk = c; this.Cc = 0; this.xc = null}; I.async.ac.prototype.get = function () {if (0 <this.Cc) {this.Cc -; var b = this.xc; this.xc = b.next; b.next = null} mais b = this.kj (); retorno b}; I.async. ac.prototype.put = function (b) {this.Yk (b); this.Cc <this.Ck&& (this.Cc ++, b.next = this.xc, this.xc = b)}; I.debug. ba = {}; I.debug.an = C (); I.debug.ba.wb = []; I.debug.ba.Xd = []; I.debug.ba.Pg =! 1; debug.ba.register = função (b) {I.debug.ba.wb [I.debug.ba.wb.length] = b; if (I.debug.ba.Pg) para (var c = I.debug .ba.Xd, d = 0; d <c.length; d ++) b (I.bind (c [d] .Tl, c [d]))}; I.debug.ba.Js = função (b) {I.debug.ba.Pg =! 0; para (var c = I.bind (b.Tl, b), d = 0; d <I.debug.ba.wb.length; d ++) I.debug. ba.wb [d] (c); I.debug.ba.Xd.push (b)}; I.debug.ba.uu = função (b) {var c = I.debug.ba.Xd; b = I.bind (bs, b);para (var d = 0; d <I.debug.ba.wb.length; d ++) I.debug.ba.wb [d] (b); c.length -}; Iaxn = C (); Iac = função (b) {this.zl = b}; Iacprototype.toString = D ( "zl"); IacUl = novo Iac ( "A"); IacVl = novo Iac ( "ABBR"); IacXl = novo Iac ( "ACRÓNIMO "); IacYl = new Iac (" ADDRESS "); Iacbm = new Iac (" applet "); Iaccm = new Iac (" AREA "); Iacdm = new Iac (" artigo "); Iacem = new Iac (" DE LADO "); Iacjm = new Iac (" AUDIO "); Iackm = new Iac (" B "); Iaclm = new Iac (" BASE "); Iacmm = new Iac (" BASEFONT "); Iacnm = new Iac (" BDI "IAC = new Iac (" BIG "); Iacsm = new Iac (" BLOCKQUOTE ");c = função (b) {this.zl = b}; Iacprototype.toString = D ("zl"); IacUl = new Iac ("A"); IacVl = new Iac ("ABBR"); IacXl = new Iac ( "sigla"); IacYl = new Iac ( "ADDRESS"); Iacbm = new Iac ( "applet"); Iaccm = new Iac ( "AREA"); Iacdm = new Iac ( "artigo"); Iacem = new Iac ( "ASIDE"); Iacjm = new Iac ("AUDIO"); Iackm = new Iac ("B"); Iaclm = new Iac ("BASE"); Iacmm = new Iac ("BASEFONT"); Iacnm = new Iac ( "BDI"); Iacom = new Iac ("BDO"); Iacrm = new Iac ("BIG"); Iacsm = new Iac ("BLOCKQUOTE");c = função (b) {this.zl = b}; Iacprototype.toString = D ("zl"); IacUl = new Iac ("A"); IacVl = new Iac ("ABBR"); IacXl = new Iac ( "sigla"); IacYl = new Iac ( "ADDRESS"); Iacbm = new Iac ( "applet"); Iaccm = new Iac ( "AREA"); Iacdm = new Iac ( "artigo"); Iacem = new Iac ( "ASIDE"); Iacjm = new Iac ("AUDIO"); Iackm = new Iac ("B"); Iaclm = new Iac ("BASE"); Iacmm = new Iac ("BASEFONT"); Iacnm = new Iac ( "BDI"); Iacom = new Iac ("BDO"); Iacrm = new Iac ("BIG"); Iacsm = new Iac ("BLOCKQUOTE");ENDEREÇO ​​"); Iacbm = new Iac (" APPLET "); Iaccm = new Iac (" AREA "); Iacdm = new Iac (" ARTICLE "); Iacem = new Iac (" ASIDE "); Iacjm = new Iac (" AUDIO "); Iackm = new Iac (" B "); Iaclm = new Iac (" BASE "); Iacmm = new Iac (" BASEFONT "); Iacnm = new Iac (" BDI "); Iacom = new Iac (" BDO "); Iacrm = new Iac (" BIG "); Iacsm = new Iac (" BLOCKQUOTE ");ENDEREÇO ​​"); Iacbm = new Iac (" APPLET "); Iaccm = new Iac (" AREA "); Iacdm = new Iac (" ARTICLE "); Iacem = new Iac (" ASIDE "); Iacjm = new Iac (" AUDIO "); Iackm = new Iac (" B "); Iaclm = new Iac (" BASE "); Iacmm = new Iac (" BASEFONT "); Iacnm = new Iac (" BDI "); Iacom = new Iac (" BDO "); Iacrm = new Iac (" BIG "); Iacsm = new Iac (" BLOCKQUOTE ");Iacrm = new Iac ("BIG"); Iacsm = new Iac ("BLOCKQUOTE");Iacrm = new Iac ("BIG"); Iacsm = new Iac ("BLOCKQUOTE");
Iactm = new Iac ("CORPO"); Iacye = novo Iac ("BR"); Iacum = novo Iac ("BOTÃO"); Iacvm = novo Iac ("CANVAS"); Iacwm = novo Iac ("CAPTION"); Iacym = new Iac ("CENTER"); Iaczm = novo Iac ("CITE"); IacAm = novo Iac ("CÓDIGO"); IacBm = novo Iac ("COL"); IacCm = novo Iac ("COLGROUP"); IacDm = new Iac ("COMMAND"); IacFm = new Iac ("DATA"); IacGm = new Iac ("DATALIST"); IacHm = new Iac ("DD"); IacIm = new Iac ("DEL"); IacKm = new Iac ("DETALHES"); IacLm = new Iac ("DFN"); IacMm = new Iac ("DIALOG");
IacNm = new Iac ("DIR"); IacOm = new Iac ("DIV"); IacPm = new Iac ("DL"); IacSm = new Iac ("DT"); IacVm = new Iac ("EM"); IacWm = new Iac ("EMBED"); Iaccn = new Iac ("FIELDSET"); Iacdn = new Iac ("FIGCAPTION"); Iacen = new Iac ("FIGURA"); Iacfn = new Iac ("FONT"); Iacgn = new Iac ("FOOTER"); Iachn = new Iac ("FORM"); Iacjn = new Iac ("FRAME"); Iackn = new Iac ("FRAMESET"); Iacmn = new Iac ("H1"); Iacn = novo Iac ("H2"); Iacon = novo Iac ("H3"); Iacpn = novo Iac ("H4"); Iacqn = new Iac ("H5");
Iacrn = new Iac ("H6"); Iacsn = new Iac ("HEAD"); Iactn = new Iac ("HEADER"); Iacun = new Iac ("HGROUP"); Iacvn = new Iac ("HR"); Iacwn = novo Iac ("HTML"); Iacyn = novo Iac ("I"); IacBn = novo Iac ("IFRAME"); IacCn = novo Iac ("IMG"); IacDn = novo Iac ("INPUT"); IacEn = new Iac ("INS"); IacJn = new Iac ("ISINDEX"); IacMn = new Iac ("KBD"); IacNn = new Iac ("KEYGEN"); IacOn = new Iac ("LABEL"); IacQn = new Iac ("LEGEND"); IacRn = new Iac ("LI"); IacSn = new Iac ("LINK"); IacWn = new Iac ("MAIN");
IacXn = novo Iac ("MAP"); IacYn = novo Iac ("MARK"); IacZn = novo Iac ("MATH"); Iac $ n = novo Iac ("MENU"); Iacao = novo Iac ("MENUITEM" Iac = new Iac ("META"); Iacco = new Iac ("METER"); Iacfo = new Iac ("NAV"); Iacho = new Iac ("NOFRAMES"); Iacio = new Iac ("NOSCRIPT") Iaclo = new Iac ("OBJECT"); Iacmo = new Iac ("OL"); Iacno = new Iac ("OPTGROUP"); Iacoo = new Iac ("OPTION"); Iacpo = new Iac ("OUTPUT") Iacqo = new Iac ("P"); Iacro = new Iac ("PARAM"); Iacso = new Iac ("PICTURE");
Iacuo = new Iac ("PRE"); Iacwo = new Iac ("PROGRESS"); IacQ = new Iac ("Q"); Iacxo = new Iac ("RP"); Iacyo = new Iac ("RT"); Iaczo = novo Iac ("RTC"); IacAo = novo Iac ("RUBY"); IacCo = novo Iac ("S"); IacFo = novo Iac ("SAMP"); IacGo = novo Iac (k); IacHo = new Iac ("SECTION"); IacIo = new Iac ("SELECT"); IacKo = new Iac ("SMALL"); IacLo = new Iac ("SOURCE"); IacMo = new Iac ("SPAN"); IacNo = new Iac ("STRIKE"); IacOo = new Iac ("STRONG"); IacPo = new Iac ("STYLE"); IacQo = new Iac ("SUB");
IacRo = new Iac ("SUMMARY"); IacSo = new Iac ("SUP"); IacTo = new Iac ("SVG"); IacU = new Iac ("TABLE"); IacVo = new Iac ("TBODY"); IacWo = new Iac ("TD"); IacXo = new Iac ("MODELO"); IacYo = new Iac ("TEXTAREA"); IacZo = new Iac ("TFOOT"); Iac $ o = new Iac ("TH" Iacap = new Iac ("THEAD"); Iacpp = new Iac ("TIME"); Iaccp = new Iac ("TITLE"); Iacep = new Iac ("TR"); Iacfp = new Iac ("TRACK") Iacjp = new Iac ("TT"); Iaclp = new Iac ("U"); Iacmp = new Iac ("UL"); Iacnp = new Iac ("VAR");
Iacop = new Iac ("VIDEO"); Iacpp = new Iac ("WBR"); IN = {}; INdj = função (b) {função de retorno () {retorno b}}; INbn = E (! 1); INIP = E (! 0); INko = E (nulo); INdk = B (); INerro = função (b) {função de retorno () {erro de lançamento (b);}}; INia = função (b) {retorno function () {throw b;}}; INlock = função (b, c) {c = c || 0; função return () {return b.apply (isto, Array.prototype.slice.call (argumentos, 0, c))}}; INRs = function (b) {função de retorno () {argumentos de retorno [b]}};
INXs = função (b, c) {var d = Array.prototype.slice.call (argumentos, 1); função de retorno () {var = Array.prototype.slice.call (argumentos); c.push.apply ( c, d); retorno b.apply (isto, c)}}; INAu = função (b, c) {retorno INol (b, INdj (c))}; INQq = função (b, c) {função de retorno ( d) {retorno c? b == d: b === d}}; INoq = função (b, c) {var d = argumentos, e = d.length; função de retorno () {var b; e & (b = d [e-1] .apply (isto, argumentos)); para (var c = e-2; 0 <= c; c -) b = d [c] .call (isto, b); retorno b }};
INol = função (b) {var c = argumentos, d = c.length; função de retorno () {para (var b, f = 0; f <d; f ++) b = c [f] .apply (isto, argumentos ); return b}}; INand = function (b) {var = argumentos, d = c.length; return function () {para (var b = 0; b <d; b ++) if (! c [b] .apply (this, arguments)) return! 1; return! 0}}; INOR = function (b) {var = argumentos, d = c.length; return function () {para (var b = 0; b < d; b ++) if (c [b] .apply (isto, argumentos)) return! 0; return! 1}}; INQs = função (b) {return function () {return! b.apply (isto, argumentos) }};
INcreate = function (b, c) {função d () {} d.prototype = b.prototype; var e = novo d; b.apply (e, Array.prototype.slice.call (argumentos, 1)); e}; INGh =! 0; INYi = função (b) {var c =! 1, d; função de retorno () {if (! INGh) retorno b (); c || (d = b (), c = ! 0); return d}}; INonce = função (b) {var c = b; função de retorno () {if (c) {var b = c; c = nulo; b ()}}}; INEq = função (b, c, d) {var e = 0; função de retorno (f) {I.global.clearTimeout (e); var g = argumentos; e = I.global.setTimeout (function () {b.apply (d g)}, c)}};
INIU = função (b, c, d) {função e () {g = I.global.setTimeout (f, c); b.apply (d, l)} função f () {g = 0; h && (h =! 1, e ())} var g = 0, h =! 1, l = []; função de retorno (b) {l = argumentos; g? H =! 0: e ()}}; INbt = função (b, c, d) {função e () {f = 0} var f = 0; função de retorno (g) {f || (f = I.global.setTimeout (e, c), b.apply (d , argumentos))}}; Se = {}; Ifu = {}; IfustartsCom = function (b, c) {return 0 == b.lastIndexOf (c, 0)}; IfuendsWith = function (b, c) {var d = b.length-c.length; retorno 0 <= d && b.indexOf (c, d) == d}; IfuFb = função (b, c) {retorno 0 == Ifuic (c, b.substr (0, c.length)); Ifugf = função (b, c) {retorno 0 == Ifuic (c, b.substr (comprimento_c.b. c.length),} Ifuhf = função (b, c ) {return b.toLowerCase () == c.toLowerCase ()}; IfuTb = function (b) {retorno / ^ [\ s \ xa0] * $ /. teste (b)}; Ifutrim = I.ed && String.prototype função .trim? (b) {return b.trim ()}:function (b) {retorno / ^ [\ s \ xa0] * ([\ s \ S] *?) [\ s \ xa0] * $ /. exec (b) [1]};
Ifuic = função (b, c) {b = Cadeia (b) .toLowerCase (); c = Cadeia (c) .toLowerCase (); retorno b <c? -1: b == c? 0: 1}; IfuWb = função (b, c) {retornar b.replace (/ (\ r \ n | \ r | \ n) / g, c? "<br />": "<br>")};
Ifuqa = função (b, c) {se (c) b = b.replace (Ifume, "& amp;"). Substitua (IfuKe, "& lt;"). Substitua (IfuHe, "& gt;"). Substitua (IfuRe , "& quot;"). replace (IfuTe, "& # 39;"). replace (IfuMe, "& # 0;"); senão {if (! Ifuxh.test (b)) retorna b; -1! = b.indexOf ("&") && (b = b.replace (Ifume, "& amp;")); - 1! = b.indexOf ("<") && (b = b.replace (IfuKe, "& lt; ")); - 1! = B.indexOf ("> ") && (b = b.replace (IfuHe," & gt; ")); - 1! = B.indexOf ('"') && (b = b .replace (IfuRe, "& quot;")); - 1! = b.indexOf ("'") && (b = b.replace (IfuTe, "& # 39;")); - 1! = b.indexOf ("\ x00") &&
(b = b.replace (IfuMe, "& # 0;"))} return b}; Ifume = / & / g; IfuKe = / </ g; IfuHe = /> / g; IfuRe = / "/ g; IfuTe = / '/ g; IfuMe = / \ x00 / g; Ifuxh = / [\ x00 & <> "'] /; Ifush = função (b) {return IfuWb (b.replace (/ / g," & # 160 ; "), void 0)}; Ifucontains = function (b, c) {return-1! = b.indexOf (c)}; Ifujc = function (b, c) {retorno Ifucontains (b.toLowerCase (), c .toLowerCase ())};
IfuYa = função (b, c) {var d = 0; b = Ifutrim (Seqüência (b)). Divisão ("."); C = Ifutrim (Seqüência (c)). Divisão ("."); var e = Math.max (b.length, c.length), f = 0; 0 = = d && f <e; f ++) {var g = b [f] || "", h = c [f] || ""; faça {g = / (\ d *) (\ D *) (. *) /. exec (g) || ["", "", "", ""]; h = / (\ d *) (\ D *) (. *) /. Exec (h) || ["", "", "", ""]; se (0 == g [0] .comprimento && 0 == h [0] Comprimento total; d = Ifujd (0 == g [1] .comprimento? 0: parseInt (g [1], 10), 0 == h [1] .comprimento? 0: parseInt (h [1], 10)) || Ifujd (0 == g [2] .comprimento, 0 == h [2] .comprimento) || Ifujd (g [2], h [2]); g = g [3]; h = h [3]} enquanto (0 == d)} retorna d};
Ifujd = função (b, c) {retornar b <c? -1: b> c? 1: 0}; Ig = {}; IguserAgent = {}; IguserAgent.B = {}; IguserAgent.B.Tf = função () {var b = IguserAgent.B.Mj (); retorno b && (b = b.userAgent)? b: ""}; IguserAgent.B.Mj = função () {return I.global.navigator}; IguserAgent. B.qh = IguserAgent.B.Tf (); IguserAgent.B.Vt = function (b) {IguserAgent.B.qh = b || IguserAgent.B.Tf ()}; IguserAgent.B.qb = function () {return IguserAgent.B.qh}; IguserAgent.BM = função (b) {return Ifucontains (IguserAgent.B.qb (), b)};
IguserAgent.B.Wd = function (b) {retorno Ifujc (IguserAgent.B.qb (), b)}; IguserAgent.B.xf = função (b) {para (var c = / (\ w [\ w] +) \ / ([^ \ s] +) \ s * (?: \ ((. *?) \))? / g, d = [], e; e = c.exec (b);) d .push ([e [1], e [2], e [3] || void 0]); return d}; I.objecto = {}; I.object.is = function (b, c) {return b === c? 0! == b || 1 / b === 1 / c: b! == b && c! == c}; I.objeto.forEach = função (b, c, d) {para (var e em b) c.call (d, b [e], e, b)}; I.object.filter = função (b, c, d) {var e = {}, f; b) c.call (d, b [f], f, b) && (e [f] = b [f]); retorno e}; I.object.map = função (b, c, d) {var e = {}, f; para (f em b) e [f] = c.call (d, b [f], f, b); retorno e}; I.object.some = função (b, c, d) {para (var e em b) se (c.call (d, b [e], e, b)) return! 0; return! 1}; I.object.every = função (b, c, d ) {para (var e em b) se (! c.call (d, b [e], e, b)) retorna! 1; return! 0};
I.object.qr = função (b) {var c = 0, d; para (d em b) c ++; retorno c}; I.objeto.nr = função (b) {para (var c em b) retorno c }; I.object.pr = function (b) {para (var c em b) retornar b [c]}; I.object.contains = function (b, c) {retornar I.object.fj (b, c )}; I.object.Er = function (b) {var c = [], d = 0, e; para (e em b) c [d ++] = b [e]; retorno c}; Rf = função (b) {var c = [], d = 0, e; para (e em b) c [d ++] = e; retorno c}; I.objeto.Dr = função (b, c) {var d = I.Pb (c), e = dc: argumentos; para (d = d? 0: 1; d <e.length; d ++) {if (null == b) return; b = b [e [d]]} retornar b};
I.object.ej = função (b, c) {retorno nulo! == b && c em b}; I.objeto.fj = função (b, c) {para (var d em b) se (b [d] = = c) return! 0; return! 1}; I.object.Bj = function (b, c, d) {para (var e em b) if (c.call (d, b [e], e, b )) return e}; I.object.Vq = função (b, c, d) {retorno (c = I.objeto.Bj (b, c, d)) && b [c]}; I.objeto.Sb = function (b) {para (var c em b) return! 1; return! 0}; I.object.clear = função (b) {para (var c em b) delete b [c]}; remove = function (b, c) {var d; (d = c em b) && delete b [c]; retorno d};
I.object.add = function (b, c, d) {if (null! == b && c em b) throw Error ('O objeto já contém a chave "' + c + '"'); I.object.set ( b, c, d)}; I.object.get = função (b, c, d) {retorno nulo! == b && c em b? b [c]: d}; I.objeto.set = função (b, c, d) {b [c] = d}, I.objeto.It = função (b, c, d) {retorno c em b b [c]: b [c] = d}, I.objeto. Xt = função (b, c, d) {se (c em b) retornar b [c]; d = d (); retorno b [c] = d}; I.objeto.Kb = função (b, c) {para (var d em b) se (! (d em c) || ​​b [d]! == c [d]) retorna! 1; para (d em c) se (! (d em b)) retorna ! 1; return! 0};
I.object.clone = funç˜ao (b) {var c = {}, d; para (d em b) c [d] = b [d]; retorno c}; I.objeto.Jl = funç˜ao (b) { var c = I.da (b); se (c == v || c == n) {se (I.Ca (b.clone)) retornar b.clone (); c = c == n? ]: {}; para (var d em b) c [d] = I.objeto.Jl (b [d]); retorno c} retorno b}; I.objeto.pu = função (b) {var c = {}, d; para (d em b) c [b [d]] = d; retorno c}; I.object.Qe = ["construtor", t, "isPrototypeOf", x, A, "toString", "valor de"];
I.object.extend = function (b, c) {para (var d, e, f = 1; f <argumentos.length; f ++) {e = argumentos [f]; para (d em e) b [d] = e [d]; para (var g = 0; g <I. object.Qe.length; g ++) d = I.objeto.Qe [g], Object.prototype.hasOwnProperty.call (e, d) && ( b [d] = e [d])}}; I.object.create = function (b) {var = argumentos.length; if (1 == c && I.isArray (arguments [0])) return I.object .create.apply (null, argumentos [0]); if (c% 2) erro de lançamento ("Número ímpar de argumentos"); para (var d = {}, e = 0; e <c; e + = 2) d [argumentos [e]] = argumentos [e + 1]; retorno d};
I.object.ij = function (b) {var = argument.length; if (1 == c && I.isArray (arguments [0])) return I.object.ij.apply (nulo, argumentos [0]); para (var d = {}, e = 0; e <c; e ++) d [argumentos [e]] =! 0; retorno d}; I.objeto.wq = função (b) {var c = b; .isFrozen &&! Object.isFrozen (b) && (c = Object.create (b), Object.freeze (c)); retorno c}; I.object.ds = function (b) {return !! Object.isFrozen && Object. isFrozen (b)};
I.object.mr = function (b, c, d) {se (! B) return []; if (! Object.getOwnPropertyNames ||! Object.getPrototypeOf) retorna I.object.Rf (b); e = {}; b && (b! == Object.prototype || c) && (b! == Function.prototype || d);) {para (var f = Object.getOwnPropertyNames (b), g = 0; g <f.length; g ++) e [f [g]] =! 0; b = Object.getPrototypeOf (b)} retornar I.object.Rf (e)}; IguserAgent.A = {}; IguserAgent.A. Lg = function () {retornar IguserAgent.BM ("Opera")}; IguserAgent.A.Qk = function () {retornar IguserAgent.BM ("Trident") || IguserAgent.BM ("MSIE")}; IguserAgent. A.Ud = function () {return IguserAgent.BM ("Edge")}; IguserAgent.A.Vd = function () {retornar IguserAgent.BM ("Firefox") || IguserAgent.BM ("FxiOS")};
IguserAgent.A.Mg = function () {return IguserAgent.BM ("Safari") &&! (IguserAgent.A.Sd () || IguserAgent.A.Td () || IguserAgent.A.Lg () || IguserAgent .A.Ud () || IguserAgent.A.Vd () || IguserAgent.A.Fg () || IguserAgent.BM ("Android"))}; IguserAgent.A.Td = função () {return IguserAgent. BM ("Coast")}; IguserAgent.A.Rk = função () {return (IguserAgent.BM ("iPad") || IguserAgent.BM ("iPhone")) &&! IguserAgent.A.Mg () &&! IguserAgent.A.Sd () &&! IguserAgent.A.Td () &&! IguserAgent.A.Vd () && I.g.userAgent.BM ("AppleWebKit")};
IguserAgent.A.Sd = function () {return (IguserAgent.BM ("Chrome") || IguserAgent.BM ("CriOS")) &&! IguserAgent.A.Ud ()}; IguserAgent.A.Pk = function ( ) {return IguserAgent.BM ("Android") &&! (IguserAgent.A.tg () || IguserAgent.A.ik () || IguserAgent.A.Pd () || IguserAgent.A.Fg ())} IguserAgent.A.Pd = IguserAgent.A.Lg; IguserAgent.A.yc = IguserAgent.A.Qk; IguserAgent.A.Ra = IguserAgent.A.Ud; IguserAgent.A.ik = IguserAgent.A.Vd; IguserAgent .A.ss = IguserAgent.A.Mg; IguserAgent.A.Xr = IguserAgent.A.Td;
IguserAgent.A.fs = IguserAgent.A.Rk; IguserAgent.A.tg = IguserAgent.A.Sd; IguserAgent.A.Ur = IguserAgent.A.Pk; IguserAgent.A.Fg = function () {return IguserAgent.BM ("Seda")};
IguseAgent.A.Nb = function () {função b (b) {b = Ijfind (b, e); retorno d [b] || ""} var c = IguserAgent.B.qb (); if (IguserAgent). A.yc ()) return IguserAgent.A.Lj (c); c = IguserAgent.B.xf (c); var d = {}; IjforEach (c, função (b) {d [b [0]] = b [1]}); var e = I.gb (I.objeto.ej, d); retorno IguserAgent.A.Pd ()? b (["Version", "Opera"]): IguserAgent.A.Ra ()? b (["Borda"]): IguserAgent.A.tg ()? b (["Chrome", "CriOS"]): (c = c [2]) && c [1] || ""} ; IguserAgent.A.za = function (b) {retorno 0 <= IfuYa (IguserAgent.A.Nb (), b)};
IguserAgent.A.Lj = função (b) {var c = / rv: * ([\ d \.] *) /. Exec (b); se (c && c [1]) retorna c [1]; c = " "; var d = / MSIE + ([\ d \.] +) /. exec (b); if (d && d [1]) if (b = / Trident \ / (\ d. \ d) /. exec ( b), "7.0" == d [1]) se (b && b [1]) mudar (b [1]) {caso "4.0": c = "8.0"; quebra; caso "5.0": c = "9.0 "; break; case" 6.0 ": c =" 10.0 "; quebra; caso" 7.0 ": c =" 11.0 "} else c =" 7.0 "; caso contrário, c = d [1]; retorno c}; IfRh =! 1; IfWh =! 1; IfXe = {Le: "\ u00a0"}; IfstartsWith = IfustartsCom; IfendsWith = IfuendsWith; IfFb = IfuFb; Ifgf = Ifugf; Ifhf = Ifuhf; Ifgu = função (b, c) {for (var d = b.split ("% s"), e = "", f = Array.prototype.slice.call (argumentos, 1); f.length && 1 <d.length;) e + = d.shift () + f .shift (); return e + d.join ("% s")}; Ifmq = função (b) {retorno b.substitua (/ [\ s \ xa0] + / g, "") .replace (/ ^ \ s + | \ s + $ / g, "")}; IfTb = IfuTb; Ifbs = função (b) {retorno 0 == b.length}; IfSb ​​= IfTb; Ifhk = function (b) {retorno IfTb (IfNk (b))};
If $ r = Ifhk; IfVr = function (b) {retorno! / [^ \ T \ n \ r] /. Teste (b)}; IfSr = função (b) {retorno! / [^ A-zA-Z ] / teste (b)}; Ifos = função (b) {retorno! / [^ 0-9] /. teste (b)}; IfTr = função (b) {retorno! / [^ a-zA-Z0 -9] /. Teste (b)}; Ifus = função (b) {retorno "" == b}; Ifvs = função (b) {retorno 1 == b.length && "" <= b && "~"> = b || "\ u0080" <= b && "\ ufffd"> = b}; Ifeu = função (b) {retorno b.replace (/ (\ r \ n | \ r | \ n) + / g, "" )}; Ifaj = function (b) {return b.replace (/ (\ r \ n | \ r | \ n) / g, "\ n")}; IfPs = função (b) {return b.replace ( / \ xa0 | \ s / g, "")};
IfOs = function (b) {retorno b.replace (/ \ xa0 | [\ t] + / g, "")}; Iflq = função (b) {retorno b.replace (/ [\ t \ r \ n] + / g, "") .replace (/ ^ [\ t \ r \ n] + | [\ t \ r \ n] + $ / g, "")}; Iftrim = Ifutrim; IftrimLeft = função (b) {return b.replace (/ ^ [\ s \ xa0] + /, "")}; IftrimRight = função (b) {return b.replace (/ [\ s \ xa0] + $ /, "")}; Ific = Ifuic;
IfQg = function (b, c, d) {se (b == c) retorna 0; se (! B) return-1; if (! C) retorna 1; para (var e = b.toLowerCase (). (d), f = c.toLowerCase (), match (d), g = Math.min (e.length, f.length), h = 0; h <g; h ++) {d = e [h]; var l = f [h]; se (d! = l) retornar b = parseInt (d, 10), éNaN (b) && (c = parseInt (l, 10), éNaN (c) &&b-c) ? bc: d <l? -1: 1} return e.length! = f.length? e.length-f.length: b <c? -1: 1}; IfQr = function (b, c) {retorno IfQg (b, c, / \ d + | \ D + / g)}; IfCj = function (b, c) {return IfQg (b, c, / \ d + | \. \ D + | \ D + / g)}; = IfCu; Ifwu = function (b) {retorna encodeURIComponent (String (b))};
Ifvu = função (b) {return decodeURIComponent (b.replace (/ \ + / g, ""))}; IfWb = IfuWb; Ifqa = função (b, c) {b = Ifuqa (b, c); IfRh && ( b = b.replace (IfVh, "& # 101;")); return b}; IfVh = / e / g; Ifoh = função (b) {return Ifcontains (b, "&") ?! IfWh && "document" em I.global?Ifph(b):IfHl(b):b};Ifsu=function(b,c){return If contém (b, "&")? Ifph (b, c): b};
Ifph = função (b, c) {var d = {"& amp;": "&", "& lt;": "<", "& gt;": ">", "& quot;": '"'}; var e = c? c.createElement ("div"): I.global.document.createElement ("div"); return b.replace (Se $ h, funo (b, c) {var f = d [b] ; if (f) retorna f; "#" == c.charAt (0) && (c = Número ("0" + c.substr (1)), isNaN (c) || ​​(f = String.fromCharCode ( c))); f || (e.innerHTML = b + "", f = e.firstChild.nodeValue.slice (0, -1)); retorno d [b] = f})};
IfHl = function (b) {retorno b.replace (/ & ([^;] +); / g, função (b, d) {switch (d) {caso "amp": retorno "&"; caso "lt ": return" <"; caso" gt ": retorno"> "; caso" quot ": return '"'; padrão: retorno "#"! = d.charAt (0) || (d = Number ("0 "+ d.substr (1)), isNaN (d))? b: String.fromCharCode (d)}})}; Se $ h = / & ([^; \ s <&] +);? / g ; Ifsh = função (b) {return IfWb (b.replace (/ / g, "& # 160;"), void 0)}; IfYs = função (b) {return b.replace (/ (^ | [\ n]) /g,"$1"+IfXe.Le)};
Iffu = função (b, c) {para (var d = c.length, e = 0; e <d; e ++) {var f = 1 = = dc: c.charAt (e); if (b. charAt (0) == f && b.charAt (b.length-1) == f) return b.substring (1, b.length-1)} retorno b}; Iftruncate = função (b, c, d) {d && (b = Ifoh (b)); b.length> c && (b = b.substring (0, c-3) + "..."); d && (b = Ifqa (b)); retorno b}; = função (b, c, d, e) {d && (b = Ifoh (b)); e && b.length> c? (e> c && (e = c), b = b.substring (0, ce) + " ... "+ b.substring (b.length-e)): b.length> c && (e = Math.floor (c / 2), b = b.substring (0, e + c% 2) +" ... "+ b.substring (b.length-e)); d && (b = Ifqa (b)); retorno b};
Iffe = {"\ x00": "\\ 0", "\ b": "\\ b", "\ f": "\\ f", "\ n": "\\ n", "\ r ":" \\ r "," \ t ":" \\ t "," \ x0B ":" \\ x0B ", '"': '\\ "'," \\ ":" \\\\ "," <":" <"}; Ifzc = {" '":" \\' "}; Ifquote = function (b) {b = String (b); para (var c = ['"'], d = 0; d <b.length; d ++) {var e = b.charAt (d), f = e.charCodeAt (0); c [d + 1] = Iffe [e] || (31 <f && 127> f e e: Ifvf (e)) cc.push ('' '); return c.join ("")}; IfRq = função (b) {para (var c = [], d = 0; d < b.length; d ++) c [d] = Ifvf (b.charAt (d)); retorno c.join ("")};
Ifvf = function (b) {if (b em Ifzc) retorna Ifzc [b]; if (b em Iffe) retorna Ifzc [b] = Iffe [b]; var c = b.charCodeAt (0); se (31 < c && 127> c) var d = b; senão {if (256> c) {se (d = "\\ x", 16> c || 256 <c) d + = "0"} mais d = "\\ u ", 4096> c && (d + =" 0 "); d + = c.toString (16) .toUpperCase ()} return Ifzc [b] = d}; If contém = Ifucontains; Ifjc = Ifujc; Iftq = função (b, c ) {return b && c? b.split (c) .comprimento-1: 0}; Ifxb = B (); Ifremove = função (b, c) {retorno b.replace (c, "")}; Ifdt = função ( b, c) {c = novo RegExp (IfYd (c), "g"); retorno b.replace (c, "")};
Ifjt = function (b, c, d) {c = novo RegExp (IfYd (c), "g"); retorno b.replace (c, d.replace (/ \ $ / g, "$$$$") )}; IfYd = function (b) {return Cadeia (b) .replace (/([-()\[\]{}+?*.$\^ |,: # <! \\]) / g, "\\ $ 1"). Replace (/ \ x08 / g, "\\ x08")}; Ifrepeat = String.prototype.repeat? Function (b, c) {retorno b.repetir (c)}: function (b , c) {return Array (c + 1) .join (b)}; IfVs = function (b, c, d) {b = IX (d)? b.toFixed (d): String (b); d = b.indexOf ("."); - 1 == d && (d = b.length); retorno Ifrepeat ("0", Math.max (0, cd)) + b}; IfNk = função (b) {return null == b? "": Cadeia (b)};
Ifcq = function (b) {retornar Array.prototype.join.call (argumentos, "")}; IfBr = function () {retornar Math.floor (2147483648 * Math.random ()). ToString (36) + Math. abs (Math.floor (2147483648 * Math.random ()) ^ I.now ()). toString (36)}; IfYa = IfuYa; IfKr = função (b) {para (var c = 0, d = 0; d <b.length; ++ d) c = 31 * c + b.charCodeAt (d) >>> 0; retorno c}; IfIl = 2147483648 * Math.random () | 0; IfCq = function () {retorno "goog _" + IfIl ++}; Ifku = function (b) {var c = Number (b); retorno 0 == c && I.f.Tb (b)? NaN: c}; Ifgs = função (b) {return / ^ [az] + ([AZ] [az] *) * $ /. teste (b)};
Ifws = função (b) {return / ^ ([AZ] [az] *) + $ /. Teste (b)}; Ifju = função (b) {return Cadeia (b) .replace (/ \ - ([az ]) / g, function (b, d) {retorno d.toUpperCase ()})}; Ifmu = function (b) {return Cadeia (b) .replace (/ ([AZ]) / g, "- $ 1" ) .toLowerCase ()}; Ifnu = function (b, c) {c = IO (c)? IfYd (c): "\\ s"; retorno b.replace (novo RegExp ("(^" + (c? "| [" + c + "] +": "") + ") ([az])", "g"), função (b, c, f) {retorno c + f.toUpperCase ()})}; Ifgq = function (b) {return Cadeia (b.charAt (0)). ToUpperCase () + Cadeia (b.substr (1)). ToLowerCase ()};
IfparseInt = function (b) {isFinite (b) && (b = String (b)); return IO (b)? / ^ \ S * -? 0x / i.test (b)? ParseInt (b, 16): parseInt (b, 10): NaN}; Se $ t = função (b, c, d) {b = b.split (c); para (var e = []; 0 <d && b.length;) e.push (b.shift ()), d -; b.length && e.push (b.join (c)); return e}; Ifzs = função (b, c) {if (c) tipo de c == y && (c = [c]); senão retorna b; para (var d = -1, e = 0; e <c.length; e ++) if (""! = c [e]) {var = b.lastIndexOf (c [e]); f> d && (d = f)} return-1 == d? b: b.slice (d + 1)};
IfLq = função (b, c) {var d = [], e = []; se (b == c) retornar 0, se (! B.length ||! C.length) retornar Math.max (b. comprimento, c.length), para (var f = 0; f <c.length + 1; f ++) d [f] = f; para (f = 0; f <b.length; f ++) {e [0] = f + 1; para (var g = 0; g <c.length; g ++) e [g + 1] = Math.min (e [g] + 1, d [g + 1] + 1, d [g ] + Número (b [f]! = C [g])), para (g = 0; g <d.length; g ++) d [g] = e [g]} retornar e [c.length]}; IguserAgent.W = {}; IguserAgent.W.tk = function () {retornar IguserAgent.BM ("Presto")}; IguserAgent.W.wk = function () {retornar IguserAgent.BM ("Trident") || IguserAgent .BM ("MSIE")}; IguserAgent.W.Ra = function () {retornar IguserAgent.BM ("Edge")}; IguserAgent.W.Hg = function () {retornar IguserAgent.B.Wd ("WebKit" ) &&! IguserAgent.W.Ra ()}; IguserAgent.W.jk = function () {return IguserAgent.BM ("Gecko") &&! IguserAgent.W.Hg () &&! IguserAgent.W.wk () &&! IguserAgent.W.Ra ()};
IguserAgent.W.Nb = function () {var b = IguserAgent.B.qb (); if (b) {b = IguserAgent.B.xf (b); var c = IguserAgent.W.Jj (b); (c) retornar "Gecko" == c [0]? IguserAgent.W.Uj (b): c [1]; b = b [0]; var d; se (b && (d = b [2]) && (d = / Trident \ / ([^ \ s;] +) /. exec (d))) retornar d [1]} retornar ""}; IguserAgent.W.Jj = function (b) {if (! IguserAgent .W.Ra ()) return b [1]; para (var c = 0; c <b.length; c ++) {var d = b [c]; se ("Borda" == d [0]) retorno d}}; IguserAgent.W.za = function (b) {retorno 0 <= IfYa (IguserAgent.W.Nb (), b)};
IguseAgent.W.Uj = function (b) {retorno (b = Ijfind (b, função (b) {retorno "Firefox" == b [0]})) && b [1] || ""}; I.async .jh = função (b) {I.global.setTimeout (function () {lance b;}, 0)}; I.async.sa = função (b, c, d) {var e = b; c && (e = I.bind (b, c)); e = I.async.sa.th (e); I.Ca (I.global.setImmediate) && (d || I.async.sa.Nl ())? I.global.setImmediate (e) :( I.async.sa. $ G || (I.async.sa. $ G = I.async.sa.Qj ()), I.async.sa. $ G ( e)); I.async.sa.Nl = function () {return I.global.Window && I.global.Window.prototype &&! IguserAgent.A.Ra () && I.global.Window.prototype.setImmediate == I. global.setImmediate?! 1:! 0};
I.async.sa.Qj = function () {var b = I.global.MessageChannel; "indefinido" === typeof b && "indefinido"! == janela typeof && window.postMessage && window.addEventListener &&! IguserAgent.W.tk () && (b = function () {var b = document.createElement ("IFRAME"); b.style.display = "nenhum"; b.src = ""; document.documentElement.appendChild (b); var c = b. contentWindow; b = c.document; b.open (); b.write (""); b.close (); var d = "callImmediate" + Math.random (), e = "file:" == c .location.protocol? "*": c.location.protocol + "//" + c.location.host; b = I.bind (função (b) {if (("*" ==
e || b.origin == e) && b.data == d) this.port1.onmessage ()}, isto); c.addEventListener ("mensagem", b,! 1); this.port1 = {}; this.port2 = {postMessage: function () {c.postMessage (d, e)}}}); if ("indefinido"! == tipo de b &&! IguserAgent.A.yc ()) {var = novo b, d = {}, e = d; c.port1.onmessage = function () {se (IX (d.next)) {d = d.next; var b = d.jf; d.jf = null; )}}; return function (b) {e.next = {jf: b}; e = e.next; c.port2.postMessage (0)}} return "undefined"! == tipo de documento && "onreadystatechange" no documento Função .createElement (k)? (b) {var c = document.createElement (k);
c.onreadystatechange = function () {c.onreadystatechange = null; c.parentNode.removeChild (c); c = nulo; b (); b = nulo}; document.documentElement.appendChild (c)}: function (b) {I.global.setTimeout (b, 0)}}; I.async.sa.th = INdk; I.debug.ba.register (função (b) {I.async.sa.th = b}); .async.Ha = function () {this.Uc = this.zb = null}; I.async.Ha.Zc = 100; I.async.Ha.Mb = novo I.async.ac (function () {return novo I.async.fd}, função (b) {b.reset ()}, I.async.Ha.Zc); I.async.Ha.prototype.add = função (b, c) {var d = I .async.Ha.Mb.get (); d.set (b, c); this.Uc? this.Uc.next = d: this.zb = d; this.Uc = d}; I.async.Ha .prototype.remove = function () {var b = nulo; this.zb && (b = this.zb, this.zb = this.zb.next, this.zb || (this.Uc = null), b.next = null); return b}; I.async.fd = function () {this.next = this.scope = this.td = nulo};
I.async.fd.prototype.set = function (b, c) {this.td = b; this.scope = c; this.next = null}; I.async.fd.prototype.reset = function () { this.next = this.scope = this.td = null}; I.Ch =! 1; I.async.R = função (b, c) {I.async.R.Nc || I.async.R. ek (); I.async.R.Tc || (I.async.R.Nc (), I.async.R.Tc =! 0); I.async.R.le.add (b, c) }; I.async.R.ek = function () {if (I.Ch || I.global.Promise && I.global.Promise.resolve) {var b = I.global.Promise.resolve (void 0); .async.R.Nc = function () {b.then (I.async.R.Jc)}} mais I.async.R.Nc = function () {I.async.sa (I.async.R. Jc)}}; I.async.R.Xq = função (b) {I.async.R.Nc = função () {I.async.sa (I.async.R.Jc); b && b (I.async .R.Jc)}}; I.async.R.Tc =! 1; I.async.R.le = novo I.async.Ha;
I. $ && (I.async.R.mt = function () {I.async.R.Tc =! 1; I.async.R.le = novo I.async.Ha}); I.async.R .Jc = function () {para (var b; b = I.async.R.le.remove ();) {tente {b.td.call (b.scope)} catch (c) {I.async. jh (c)} I.async.Ha.Mb.put (b)} I.async.R.Tc =! 1}; Iao = {}; IaoRp = C (); IaoDb = B (); IaoFp = C (); IaoMi = função (b) {retorno IaoDb (b)}; IaoMp = C (); IaoLp = C (); IaoGp = C (); IaoQp = C (); IaoOi = função (b) {return IaoDb (b)} IaoPp = função (b) {retorno IaoDb (b)}; IaoHp = função (b) {retorno IaoDb (b)}; IaoIp = C (); IaoNi = função (b) {retorno IaoDb (b) Ia Jp = C (); IaoKp = C (); IaoNp = C (); IaoOp = C ();
IaoFq = function (b) {retorno I.la (b)? B.constructor.displayName || b.constructor.name || Object.prototype.toString.call (b): void 0 === b? "Indefinido" : null === b? "null": typeof b}; Iaouc = função (b) {return (b = b & proprietário.documento) && (b.defaultView || b.parentWindow) || I.global}; IguserAgent. platform = {}; IguserAgent.platform.sg = function () {retornar IguserAgent.BM ("Android")}; IguserAgent.platform.Cg = function () {retornar IguserAgent.BM ("iPod")}; IguserAgent.platform .Bg = function () {return IguserAgent.BM ("iPhone") &&! IguserAgent.BM ("iPod") &&! IguserAgent.BM ("iPad")}; IguserAgent.platform.Ag = função () {return IguserAgent .BM ("iPad")}; IguserAgent.platform.zg = function () {return IguserAgent.platform.Bg () || IguserAgent.platform.Ag () || IguserAgent.platform.Cg ()};
IguserAgent.platform.Dg = function () {retornar IguserAgent.BM ("Macintosh")}; IguserAgent.platform.qk = function () {retornar IguserAgent.BM ("Linux")}; IguserAgent.platform.Jg = function ( ) {return IguserAgent.BM ("Windows")}; IguserAgent.platform.ug = function () {retornar IguserAgent.BM ("CrOS")}; IguserAgent.platform.Wr = function () {return IguserAgent.BM (" CrKey ")}; IguserAgent.platform.nk = function () {retornar IguserAgent.B.Wd (" KaiOS ")}; IguserAgent.platform.kk = function () {retornar IguserAgent.B.Wd (" GAFP ")} ;
IguserAgent.platform.Nb = function () {var b = IguserAgent.B.qb (), c = ""; IguserAgent.platform.Jg ()? (C = / Windows (?: NT | Telefone) ([0- 9.] +) /, C = (b = c.exec (b))? B [1]: "0.0"): IguserAgent.platform.zg ()? (C = / (?: iPhone | iPod | iPad | CPU) \ s + OS \ s + (\ S +) /, c = (b = c.exec (b)) && b [1] .replace (/ _ / g, ".")): IguserAgent.platform.Dg ()? (c = / Mac OS X ([0-9 _.] +) /, c = (b = c.exec (b))? b [1] .replace (/ _ / g, ".") : "10"): IguserAgent.platform.sg ()? (C = / Android \ s + ([^ \);] +) (\) |;) /, c = (b = c.exec (b)) && b [1]): IguserAgent.platform.ug () && (c = / (?: CrOS \ s + (?: i686 | x86_64) \ s + ([0-9.] +)) /,
c = (b = c.exec (b)) && b [1]); return c || ""}; IguserAgent.platform.za = function (b) {retorno 0 <= IfYa (IguserAgent.platform.Nb () b)}; I.Ia = {}; I.I.objeto = funç˜ao (b, c) {retorno c}; I.Ia.ee = funç˜ao (b) {I.Ia.ee [""] ( b); return b}; I.Ia.ee [""] = I.fb; I.Ia.eq = função (b, c) {try {return I.I.ee (b [c])! 0} catch (d) {} ​​retornar! 1}; I.Ia.cache = function (b, c, d, e) {e = e? E (c): c; return Objeto.prototipo.hasOwnProperty.call ( b, e)? b [e]: b [e] = d (c)}; I.userAgent = {}; I.userAgent.qe =! 1; I.userAgent.oe =! 1; I.userAgent. pe =! 1; I.userAgent.ve =! 1; I.userAgent.Yc =! 1; I.userAgent.te =! 1; I.userAgent.yh =! 1; I.userAgent.Ab = I.userAgent .qe || I.userAgent.oe || I.userAgent.pe || I.userAgent.Yc || I.userAgent.ve || I.userAgent.te; I.userAgent.Tj = function () {return IguserAgent .B.qb ()}; I.userAgent.Fd = function () {retorno I.global.navigator || null}; I.userAgent.yr = function () {retorno I.userAgent.Fd ()}; I.userAgent.Oe = I.userAgent.Ab? I.userAgent.te: IguserAgent.A.Pd ();
I.userAgent.aa = I.userAgent.Ab? I.userAgent.qe: IguserAgent.A.yc (); I.userAgent.Ce = euuserAgent.Ab? I.userAgent.oe: IguserAgent.W.Ra ( ); I.userAgent.Um = I.userAgent.Ce || I.userAgent.aa; I.userAgent.ad = I.userAgent.Ab? I.userAgent.pe: IguserAgent.W.jk (); I.userAgent .Cb = I.userAgent.Ab? I.userAgent.ve || I.userAgent.Yc: IguserAgent.W.Hg (); I.userAgent.sk = function () {retorno I.userAgent.Cb && I.g.userAgent .BM ("Mobile")}; I.userAgent.eo = I.userAgent.Yc || I.userAgent.sk (); I.userAgent.Do = I.userAgent.Cb;
I.userAgent.pj = function () {var b = euuserAgent.Fd (); retorno b && b.platform || ""}; I.userAgent.to = I.userAgent.pj (); I.userAgent.se =! 1; I.userAgent.we =! 1; I.userAgent.re =! 1; I.userAgent.xe =! 1; I.userAgent.ne =! 1; I.userAgent.Wc =! 1; .userAgent.Vc =! 1; I.userAgent.Xc =! 1; I.userAgent.Bh =! 1; I.userAgent.Ah =! 1; I.userAgent.va = I.userAgent.se || I. userAgent.we || I.userAgent.re || I.userAgent.xe || I.userAgent.ne || I.userAgent.Wc || I.userAgent.Vc || I.userAgent.Xc; I.userAgent. Vn = I.userAgent.va? I.userAgent.se: IguserAgent.platform.Dg ();
I.userAgent.qp = I.userAgent.va? I.userAgent.we: IguserAgent.platform.Jg (); I.userAgent.pk = function () {return IguserAgent.platform.qk () || IguserAgent.platform. ug ()}; I.userAgent.Tn = I.userAgent.va? I.userAgent.re: I.userAgent.pk (); I.userAgent.Ak = function () {var b = I.userAgent.Fd ( ); return !! b && I.f.contains (b.appVersion || "", "X11")}; I.userAgent.rp = I.userAgent.va? I.userAgent.xe: I.userAgent.Ak () ; I.userAgent.am = I.userAgent.va? I.userAgent.ne: IguserAgent.platform.sg ();
I.userAgent.Hn = I.userAgent.va? I.userAgent.Wc: IguserAgent.platform.Bg (); I.userAgent.Gn = I.userAgent.va? I.userAgent.Vc: IguserAgent.platform.Ag ( ); I.userAgent.In = I.userAgent.va? I.userAgent.Xc: IguserAgent.platform.Cg (); I.userAgent.Fn = I.userAgent.va? I.userAgent.Wc || I.userAgent .Vc || I.userAgent.Xc: IguserAgent.platform.zg (); I.userAgent.Ln = I.userAgent.va? I.userAgent.Bh: IguserAgent.platform.nk (); I.userAgent.ln = I.userAgent.va?I.userAgent.Ah:IguserAgent.platform.kk ();
I.userAgent.qj = function () {var b = "", c = eu_usuario.Vj (); c && (b = c? C [1]: ""); retorno I.userAgent.aa && (c = I.userAgent.Kf (), nulo! = C && c> parseFloat (b))? Cadeia (c): b}; I.userAgent.Vj = function () {var b = l_useruser.Tj (); if ( I.userAgent.ad) return / rv: ([^ \);] +) (\) |;) /. Exec (b); se (I.userAgent.Ce) retornar / Borda \ / ([\ d \ .] +) /. exec (b); se (I.userAgent.aa) retornar / \ b (?: MSIE | rv) [:] ([^ \);] +) (\) |;) /. exec (b); se (I.userAgent.Cb) retornar / WebKit \ / (\ S +) /. exec (b); se (I.userAgent.Oe) retornar / (?: Versão) [\ /]? \ S +) /. Exec (b)};
I.userAgent.Kf = function () {var b = I.global.document; retorno b? B.documentMode: void 0}; I.userAgent.VERSION = I.userAgent.qj (); I.userAgent.compare = function (b, c) {return IfYa (b, c)}; I.userAgent.yk = {}; I.userAgent.za = função (b) {retorno I.userAgent.yh || I.Ia.cache ( I.userAgent.yk, b, function () {retornar 0 <= IfYa (I.userAgent.VERSION, b)})}; I.userAgent.xs = I.userAgent.za; I.userAgent.Rb = function ( b) {return Número (I.userAgent.Uh)> = b}; I.userAgent.Zr = I.userAgent.Rb; var J; var K = I.global.document, ba = I.userAgent.Kf () ;
J = K & I.userAgent.aa? Ba || ("CSS1Compat" == K.compatMode? ParseInt (eu.userAgent.VERSION, 10): 5): void 0; I.userAgent.Uh = J; Iaib = {Hh :! I.userAgent.aa || I.userAgent.Rb (9), Ih:! I.userAgent.ad &&! I.userAgent.aa || I.userAgent.aa && I.userAgent.Rb (9) || I. userAgent.ad && I.userAgent.za ("1.9.1"), ze: I.userAgent.aa &&! I.userAgent.za ("9"), Jh: I.userAgent.aa || I.userAgent.Oe || I.userAgent.Cb, ai: I.userAgent.aa, Pn: I.userAgent.aa &&! I.userAgent.Rb (9)}; Iatags = {}; Iatags.Fi = {area:! 0, base:! 0, br:! 0, col:! 0, comando:! 0, inserir:! 0, hr:! 0, img:! 0, entrada:! 0, keygen:! 0, link:! 0, meta:! 0, param:! 0, fonte:! 0, trilha:! 0, wbr:! 0}; Iatags.zk = função (b) {retorno! 0 === Iatags.Fi [b]}; Ifkp = C ( ); IfI = função (b, c) {this.ie = b === IfIGe && c || ""; this.vi = IfIVe}; IfIprototype.ya =! 0; IfIprototype.ka = D ("ie");IfIprototype.toString = function () {return "Const {" + this.ie + "}"}; IfIs = function (b) {if (b instanceof IfI && b.constructor === IfI && b.vi === IfIVe) retorna b. ie Ioia ("objeto esperado do tipo Const, got '" + b + "'"); return "type_error: Const"}; IfIfrom = function (b) {return novo IfI (IfIGe, b)}; IfIVe = {} ; IfIGe = {}; IfIEMPTY = IfIfrom (""); Ib = {}; IbP = function () {this.Ec = ""; this.ki = IbPea}; IbPprototype.ya =! 0; IbPea = {} ; IbPqc = função (b) {b = IfIs (b); retorno 0 === b.length? IbPEMPTY: IbPGb (b)}; IbPar = função (b, c) {para (var d = [], e = 1; e <argumentos.length; e ++) d.push (IbPgh (argumentos [e])); return IbPGb ("(" + IfIs (b) + ") (" + d.join (",") + ");")}; IbPfr = função (b) {return IbPGb (IbPgh (b))}; IbPprototype.ka = D ("Ec"); I. $ && (IbPprototype.toString = function () {retornar "SafeScript {" + this.Ec + "}"});
IbPs = function (b) {if (b instanceof IbP && b.constructor === IbP && b.ki === IbPea) return b.Ec; Ioia ("objeto esperado do tipo SafeScript, obtido '" + b + a + I.da (b)); return "type_error: SafeScript"}; IbPgh = function (b) {retornar JSON.stringify (b) .replace (/ </ g, "\\ x3c")}; IbPGb = função (b) { retorno (novo IbP) .cb (b)}; IbPprototype.cb = função (b) {this.Ec = b; retornar isto}; IbPEMPTY = IbPGb (""); I.xa = {}; I.xa. url = {}; I.xa.url.gj = funç˜ao (b) {return I.xa.url.hg (). createObjectURL (b)}; I.xa.url.nt = funç˜ao (b) {I. xa.url.hg (). revokeObjectURL (b)}; I.xa.url.hg = função () {var b = I.xa.url.Bf (); se (nulo! = b) retorno b; Erro ("Este navegador não parece suportar URLs de blobs");}; I.xa.url.Bf = function () {return IX (I.global.URL) && I.X (I.global.URL.createObjectURL ) I.global.URL: IX (I.global.webkitURL) && I.X (I.global.webkitURL.createObjectURL)? I.global.webkitURL: IX (I.global.createObjectURL)? I.global: nulo};
I.xa.url.aq = function () {retorno null! = I.xa.url.Bf ()}; Ih = {}; Ihi = {}; IhiYh =! 1;
IhiJe = IhiYh || ("ar" == IKsubstring (0,2) .toLowerCase () || "fa" == IKsubstring (0,2) .toLowerCase () || "he" == IKsubstring (0,2 ) .toLowerCase () || "iw" == IKsubstring (0,2) .toLowerCase () || "ps" == IKsubstring (0,2) .toLowerCase () || "sd" == IKsubstring (0, 2) .toLowerCase () || "ug" == IKsubstring (0,2) .toLowerCase () || "ur" == IKsubstring (0,2) .toLowerCase () || "yi" == IKsubstring (0 , 2) .toLowerCase ()) && (2 == IKlength || "-" == IKsubstring (2,3) || "_" == IKsubstring (2,3)) || 3 <= IKlength && "ckb" == IKsubstring (0,3) .toLowerCase () &&
(3 == IKlength || "-" == IKsubstring (3,4) || "_" == IKsubstring (3,4)) || 7 <= IKlength && ("-" == IKsubstring (2,3) || "_" == IKsubstring (2,3)) && ("adlm" == IKsubstring (3,7) .toLowerCase () || "arab" == IKsubstring (3,7) .toLowerCase () || "hebr" == IKsubstring (3,7) .toLowerCase () || "nkoo" == IKsubstring (3,7) .toLowerCase () || "rohg" == IKsubstring (3,7) .toLowerCase () | | "thaa" == IKsubstring (3,7) .toLowerCase ()) || 8 <= IKlength && ("-" == IKsubstring (3,4) || "_" == IKsubstring (3,4)) && ("adlm" == IKsubstring (4,8) .toLowerCase () || "arab" ==
IKsubstring (4,8) .toLowerCase () || "hebr" == IKsubstring (4,8) .toLowerCase () || "nkoo" == IKsubstring (4,8) .toLowerCase () || "rohg" = = IKsubstring (4,8) .toLowerCase () || "thaa" == IKsubstring (4,8) .toLowerCase ()); Ihimb = {ci: "\ u202a", gi: "\ u202b", Pe: " \ u202c ", di:" \ u200e ", oi:" \ u200f "}; IhiT = {Ta: 1, Ua: -1, ua: 0}; Ihidc =" direita "; Ihibc =" esquerda "; Ihibe Ihibc: Ihidc Ihizn = Ihi Je Ihidc: Ihibc;
IhiCl = function (b) {retorno typeof b == u? 0 <b? IhiTTa: 0> b? IhiTUa: IhiTua: null == b? Null: b? IhiTUa: IhiTTa}; Ihitb = "A-Za-z \ u00c0- \ u00d6 \ u00d8- \ u00f6 \ u00f8- \ u02b8 \ u0300- \ u0590 \ u0900- \ u1fff \ u200e \ u2c00- \ ud801 \ ud804- \ ud839 \ ud83c- \ udbff \ uf900- \ ufb1c \ ufe00- \ ufe6f \ ufefd- \ uffff "; Ihiyb =" \ u0591- \ u06ef \ u06fa- \ u08ff \ u200f \ ud802- \ ud803 \ ud83a- \ ud83b \ ufb1d- \ ufdff \ ufe70- \ ufefc "; Ihibk = / < [^>] *> | & [^;] +; / g; IhiSa = função (b, c) {retorno c? b.replace (Ihibk, ""): b};
Ihicl = new RegExp ("[" + Ihiyb + "]"); IhiJk = novo RegExp ("[" + Ihitb + "]"); IhiHd = função (b, c) {retorno Ihicl.test (IhiSa (b, c) IHIr = IhiIr = IhiHd; Ihikg = function (b) {retornar IhiJk.test (IhiSa (b, void 0))}; IhiMk = novo RegExp ("^ [" + Ihitb + "]"); Ihihl = new RegExp ( "^ [" + Ihiyb + "]"); Ihiuk = função (b) {retorno Ihihl.test (b)}; Ihirk = função (b) {retorno IhiMk.test (b)}; Ihils = função (b) { return! Ihirk (b) &&! Ihiuk (b)}; IhiKk = new RegExp ("^ [^" + Ihiyb + "] * [" + Ihitb + "]");
Ihiel = new RegExp ("^ [^" + Ihitb + "] * [" + Ihiyb + "]"); Ihieh = função (b, c) {retorno Ihiel.test (IhiSa (b, c))}; Ihirs = Ihieh ; Ihivl = function (b, c) {retornar IhiKk.test (IhiSa (b, c)); Ihijs = Ihivl; IhiEg = / ^ http: \ / \ /.*/; Ihims = função (b, c) {b = IhiSa (b, c); retorno IhiEg.test (b) ||! Ihikg (b) &&! IhiHd (b)}; IhiLk = new RegExp ("[" + Ihitb + "] [^" + Ihiyb + " ] * $ "); Ihifl = new RegExp (" ["+ Ihiyb +"] [^ "+ Ihitb +"] * $ "); Ihitj = function (b, c) {retornar IhiLk.test (IhiSa (b, c) )};
Ihihs = Ihitj; Ihiuj = função (b, c) {retorno Ihifl.test (IhiSa (b, c))}; Ihips = Ihiuj; Ihigl = / ^ (ar | ckb | dv | ele | iw | fa | nqo | ps | sd | ug | ur | yi |. * [-_] (Adlm | Árabe | Hebr | Nkoo | Rohg | Thaa)) (?!. * [-_] (Latn | Cyrl) ($ | - | _ )) ($ | - | _) / i; Ihiqs = função (b) {retorno Ihigl.test (b)}; IhiWi = / (\ (. *? \) +) | (\ [. *? \] +) | (\ {. *? \} +) | (<. *?> +) / g; IhiHr = funç˜ao (b, c) {c = (void 0 === c? IhiHd (b): c ) Ihimb.hi: Ihimb.di; return b.replace (IhiWi, c + "$ &" + c)};
IhiOq = function (b) {retorno "<" == b.charAt (0)? B.replace (/ <\ w + /, "$ & dir = rtl"): "\ n <span dir = rtl>" + b + "</ span>"}; IhiPq = função (b) {retorno Ihimb.gi + b + Ihimb.Pe}; IhiMq = função (b) {retorno "<" == b.charAt (0)? b. substitua (/ <\ w + /, "$ & dir = ltr"): "\ n <span dir = ltr>" + b + "</ span>"}; IhiNq = função (b) {retorno Ihimb.ci + b + Ihir.Pe}; Ihirj = /: \ s * ([. \ D] [. \ W] *) \ s + ([. \ D] [. \ W] *) \ s + ([. \ D] [ . \ w] *) \ s + ([. \ d] [. \ w] *) / g; IhiBk = / left / gi; Ihibl = / right / gi; IhiAl = / %%%% / g;
IhiHs = function (b) {retornar b.replace (Ihirj, ": $ 1 $ 4 $ 3 $ 2"). Substituir (IhiBk, "%%%%"). Substituir (Ihibl, Ihibc) .replace (IhiAl, Ihidc)}; Ihisj = / ([\ u0591- \ u05f2]) "/ g; Ihitl = / ([\ u0591- \ u05f2]) '/ g; IhiMs = função (b) {return b.replace (Ihisj," $ 1 \ u05f4 ") .replace (Ihitl," $ 1 \ u05f3 ")}; IhiRl = / \ s + /; Ihiak = / [\ d \ u06f0- \ u06f9] /; Ihidl = .4;
Ihiwf = função (b, c) {var d = 0, e = 0, f =! 1; b = IhiSa (b, c) .split (IhiRl); para (c = 0; c <b.length; c ++ ) {var g = b [c]; Ihieh (g)? (d ++, e ++): IhiEg.test (g)? f =! 0: Ihikg (g)? e ++: Ihiak.test (g) && (f = ! 0)} retorno 0 == e? F? IhiTTa: IhiTua: d / e> Ihidl? IhiTUa: IhiTTa}; IhiHq = funo (b, c) {retorno Ihiwf (b, c) == IhiTUa}; IhiCt = function (b, c) {b && (c = IhiCl (c)) && (b.style.textAlign = c == IhiTUa? Idhc: Ihibc, b.dir = c == IhiTUa? "rtl": "ltr") };
IhiDt = função (b, c) {troca (Ihiwf (c)) {caso IhiTTa: b.dir = "ltr"; quebra; caso IhiTUa: b.dir = "rtl"; quebra; padrão: b.removeAttribute (" dir ")}}; IhiTm = C (); IbD = funo () {this.Ic =" "; this.xi = IbDea}; IbDprototype.ya =! 0; IbDprototype.ka = D (" Ic "); IbDprototype.Jd =! 0; IbDprototype. $ A = function () {retorno IhiTTa}; I. $ && (IbDprototype.toString = function () {retorno "TrustedResourceUrl {" + this.Ic + "}"}); IbDs = function (b) {if (b instanceof IbD && b.constructor === IbD && b.xi === IbDea) return b.Ic; Ioia ("objeto esperado do tipo TrustedResourceUrl, obtido '" + b + a + I.da (b )); return "type_error: TrustedResourceUrl"};
Formatação IbD = função (b, c) {var d = IfIs (b); if (! IbDEh.test (d)) erro de lançamento ("Formato TrustedResourceUrl inválido:" + d); b = d.replace (IbDZh, função ( b, f) {if (! Object.prototype.hasOwnProperty.call (c, f)) Erro de lançamento ('Marcador encontrado', '+ f +' ", em formato string," '+ d +' ", mas nenhum rótulo válido mapeamento encontrado em args: '+ JSON.stringify (c)); b = c [f]; return b instanceof IfI? IfIs (b): encodeURIComponent (Cadeia (b))}); return IbDJb (b)}; IbDZh = /% {(\ w +)} / g; IbDEh = / ^ ((https:)? \ / \ / [0-9a-z.: [\] -] + \ / | \ / [^ / \\ ] | [^: / \\%] + \ / | [^: / \\%] * [? #] | sobre: ​​em branco #) / i;
Ibdai = / ^ ([^? #] *) (\? [^ #] *)? (# [\ S \ S] *)? /; IbDYq = função (b, c, d, e) {b = Formato IbD (b, c); b = IbDs (b); b = IbDAi.exec (b); c = b [3] || ""; return IbDJb (b [1] + IbDfh ("?", B [ 2] || "", d) + IbDfh ("#", c, e))}; IbDqc = função (b) {retorno IbDJb (IfIs (b))}; IbDcr = função (b) {for (var c = "", d = 0; d <b.length; d ++) c + = IfIs (b [d]); retorno IbDJb (c)}; IbDea = {}; IbDJb = funo (b) {var c = novo IbD; c.Ic = b; return c};
IbDfh = function (b, c, d) {se (null == d) retornar c; if (IO (d)) retornar d? B + encodeURIComponent (d): ""; para (var e em d) {var f = d [e]; f = I.isArray (f)? f: [f]; para (var g = 0; g <f.length; g ++) {var h = f [g]; null! = h && (c || (c = b), c + = (c.length> b.length? "&": "") + encodeURIComponent (e) + "=" + encodeURIComponent (Cadeia (h)))}} return c }; Ibl = function () {this.Hc = ""; this.ni = Iblea}; Iblha = "about: inválido # zClosurez"; Iblprototype.ya =! 0; Iblprototype.ka = D ("Hc"); Iblprototype.Jd =! 0; Iblprototype. $ A = function () {retorno IhiTTa}; I. $ && (Iblprototype.toString = function () {retorno "SafeUrl {" + this.Hc + "}"}); Ibls = function (b) {if (b instanceof Ibl && b.constructor === Ibl && b.ni === Iblea) return b.Hc; Ioia ("objeto esperado do tipo SafeUrl, got '"+ b + a + I.da (b)); retorno" type_error: Sa feUrl "}; Iblqc = função (b) {return Iblpa (IfIs (b))};
IbSe = / ^ (?: audio \ / (?: 3gpp2 | 3gpp | aac | L16 | midi | mp3 | mp4 | mpeg | oga | ogg | opus | x-m4a | x-wav | wav | webm) | imagem \ / (?: bmp | GIF | jpeg | jpg | png | tiff | webp) | texto \ / csv | video \ / (?: mpeg | mp4 | ogg | webm | quicktime)) $ / i; Ibl $ q = função (b) {b = IbSe.test (b.type)? I.xa.url.gj (b): Iblha; retorna Iblpa (b)}; IbOh = / ^ data: ([^ ;,] *); base64, [a-z0-9 + \ /] + = * $ / i; Ibldr = função (b) {b = b.replace (/ (% 0A |% 0D) / g, ""); var c = b.match (IbOh); c = c && I.b.Se.test (c [1]); retorno Iblpa (c? b: Iblha)};
Iblkr = função (b) {IfuFb (b, "tel:") || (b = Iblha); retorna Iblpa (b)}; Ibsi = / ^ sip [s]?: [+ A-z0-9_.! $% & '* \ / = ^ `{|} ~ -] + @ ([a-z0-9 -] + \.) + [a-z0-9] {2,63} $ / i; Iblir = function (b) {Ibsi.test (decodeURIComponent (b)) || (b = Iblha); return Iblpa (b)}; Ibler = function (b) {IfuFb (b, "fb-messenger: // share") || (b = Iblha); return Iblpa (b)}; Ibljr = function (b) {IfuFb (b, "sms:") && I.blvk (b) || (b = Iblha); retorno Iblpa (b) };
Iblvk = function (b) {var = b.indexOf ("#"); 0 <c && (b = b.substring (0, c)); c = b.match (/ [? &] Body = / gi ); if (! c) return! 0; if (1 <c.length) retorna! 1; b = b.match (/ [? &] body = ([^ &] *) /) [1]; (! b) return! 0; try {decodeURIComponent (b)} catch (d) {return! 1} return / ^ (?: [a-z0-9 \ -_. ~] |% [0-9a-f ] {2}) + $ / i.test (b)}; Iblvt = function (b, c) {retornar Iblae (/ ^ chrome-extension: \ / \ / ([^ \ /] +) \ //, b, c)}; Iblxt = função (b, c) {retornar Iblae (/ ^ moz-extensão: \ / \ / ([^ \ /] +) \ //, b, c)};
Iblwt = function (b, c) {retorno Iblae (/ ^ ms-browser-extension: \ / \ / ([^ \ /] +) \ //, b, c)}; Iblae = funo (b, c, d) {(b = b.exec (c))? (b = b [1], - 1 == (d exemplo de IfI? [IfIs (d)]: d.map (funo (b) {retorno IfIs ( b)})). indexOf (b) && (c = Iblha)): c = Iblha; retorno Iblpa (c)}; Ibllr = função (b) {retorno Iblpa (IbDs (b))}; Ibdd = / ^ (? :( ?: https? | mailto | ftp): | [^: /? #] * (?: [/? #] | $)) / i; IblEo = Ibdd;
IblMc = function (b) {se (b instanceof Ibl) retornar b; b = typeof b == v && b.ya? B.ka (): Seqüência (b); Ibdd.test (b) || (b = Iblha) ; return Iblpa (b)}; Iblta = function (b) {se (b instanceof Ibl) retornar b; b = typeof b == v && b.ya? b.ka (): String (b); Ibdd.test (b ) || (b = Iblha); return Iblpa (b)}; Iblea = {}; Iblpa = function (b) {var c = novo Ibl; c.Hc = b; retorno c}; IblWl = Iblpa ("sobre : em branco "); Ibw = função () {this.Gc =" "; this.mi = Ibwea}; Ibwprototype.ya =! 0; Ibwea = {}; Ibwqc = função (b) {b = IfIs (b) ; retorno 0 === b.length? IbwEMPTY: IbwHb (b)}; Ibwiq = C (); Ibwprototype.ka = D ("Gc"); I. $ && (Ibwprototype.toString = function () {retorno " SafeStyle {"+ this.Gc +"} "}); Ibws = função (b) {if (b instanceof Ibw && b.constructor === Ibw && b.mi === Ibwea) return b.Gc; Ioia ("objeto esperado do tipo SafeStyle, obteve '"+ b + a + I.da (b)); retorno" type_error: SafeStyle "}; IbwHb = função (b) {return (novo Ibw) .cb (b)};
Ibwprototype.cb = function (b) {this.Gc = b; retorna isto}; IbwEMPTY = IbwHb (""); Ibwha = "zClosurez"; Ibwcreate = função (b) {var c = "", d; d em b) {se (! / ^ [-_a-zA-Z0-9] + $ /. teste (d)) Erro de lançamento ("Nome permite somente [-_a-zA-Z0-9], obteve:" + d); var e = b [d]; null! = e && (e = I.isArray (e)? Ijmap (e, IbwWg) .join (""): IbwWg (e), c + = d + ":" + e + ";")} return c? IbwHb (c): IbwEMPTY};
IbwWg = function (b) {return b instância de Ibl? 'Url ("' + Ibls (b) .replace (/ </ g,"% 3c "). Replace (/ [\\"] / g, "\\ $ & ") + '")': b instância de IfI? IfIs (b): Ibwll (String (b))};
Ibwll = função (b) {var c = b.replace (IbwFe, "$ 1"). Substitua (IbwFe, "$ 1"). Substitua (IbwWe, "url"); se (IbwCi.test (c)) {se (IbwMh.test (b)) return Ioia ("Valor da cadeia não permite comentários, tem:" + b), Ibwha; if (! IbwYj (b)) retorna Ioia ("Valor da cadeia requer citações balanceadas, obteve:" + b) , Ibwha; if (! IbwZj (b)) return Ioia ("Valor de cadeia requer colchetes equilibrados e um identificador por par de parênteses, obteve:" + b), Ibwha} else return Ioia ("Valor de cadeia permite somente" + IbwZe + "e funções simples, tenho:" +
b), Ibwha; retorne Ibwml (b)}; IbwYj = função (b) {para (var c =! 0, d =! 0, e = 0; e <b.length; e ++) {var f = b. charAt (e); "'" == f && d? c =! c:' "'== f && c && (d =! d)} retorno c && d}; IbwZj = function (b) {para (var c =! 0, d = / ^ [-_a-zA-Z0-9] $ /, e = 0; e <b.length; e ++) {var f = b.charAt (e); if ("]" == f) {se (c) return! 1; c =! 0} else if ("[" == f) {se (! c) retornar! 1; c =! 1} else if (! c &&! d.test (f)) return! 1} return c}; IbwZe = "[- ,. \" '% _! # a-zA-Z0-9 \\ [\\]] "; IbwCi = novo RegExp (" ^ "+ IbwZe +" + $ "); IbwWe = / \ b (url \ ([\ t \ n] *) ('[- & (- \ [\] - ~] *' |" [! # - \ [\] - ~] * "| [! # - & * - \ [\] - ~] *) ([\ t \ n] * \)) / g;
IbwFe = / \ b (hsl | hsla | rgb | rgba | matriz | calc | minmax | ajuste de conteúdo | repetição | (rotação | escala | tradução) (X | Y | Z | 3d)?) \ ([- + * / 0-9a-z.% \ [\],] + \) / G; IbwMh = / \ / \ * /; Ibwml = função (b) {retorno b.replace (IbwWe, função (b, d, e , f) {var c = ""; e = e.replace (/ ^ (['"]) (. *) \ 1 $ /, função (b, d, e) {c = d; retorno e}} b = IblMc (e) .ka (); retorno d + c + b + c + f})}; Ibwconcat = funç˜ao (b) {funç˜ao c (b) {I.isArray (b)? IjforEach (b, c): d + = Ibws (b)} var d = ""; IjforEach (arguments, c); return d? IbwHb (d): IbwEMPTY}; IbS = function () {this.Fc = ""; this.li = IbSea}; IbSprototype.ya =! 0; IbSea = {};
IbSyq = função (b, c) {if (Ifucontains (b, "<")) Erro de lançamento ("Seletor não permite '<', obtido:" + b); var d = b.replace (/ ('| ") ((?! \ 1) [^ \ r \ n \ f \\] | \\ [\ s \ S]) * \ 1 / g," "); if (! / ^ [-_A-zA -Z0-9 #.: *,> + ~ [\] () = ^ $ |] + $ /. Teste (d)) Erro de lançamento ("Seletor permite apenas [-_a-zA-Z0-9 # .: *,> + ~ [\\] () = ^ $ |] e strings, tem: "+ b); if (! IbSXj (d)) erro de lançamento (" () e [] no seletor deve ser balanceado, tem : "+ b); c exemplo de Ibw || (c = Ibwcreate (c)); b = b +" {"+ Ibws (c) +"} "; return IbSIb (b)};
IbSXj = função (b) {para (var c = {"(": ")", "[": "]"}, d = [], e = 0; e <b.length; e ++) {var f = b [e]; if (c [f]) ​​d.push (c [f]), senão se (I.objeto.contains (c, f) & d.pop ()! = f) return! 1} return 0 == d.length}; IbSconcat = function (b) {funç˜ao c (b) {I.isArray (b)? IjforEach (b, c): d + = IbSs (b)} var d = ""; IjforEach ( argumentos, c); retorno IbSIb (d)}; IbSqc = função (b) {b = IfIs (b); retorno 0 === b.length? IbSEMPTY: IbSIb (b)}; IbSprototype.ka = D (" Fc "); I. $ && (IbSprototype.toString = function () {retornar" SafeStyleSheet {"+ this.Fc +"} "});
IbSs = function (b) {if (b instanceof IbS && b.constructor === IbS && b.li === IbSea) retorno b.Fc; Ioia ("objeto esperado do tipo SafeStyleSheet, obtido '" + b + a + I.da (b)); return "type_error: SafeStyleSheet"}; IbSIb = função (b) {return (novo IbS) .cb (b)}; IbSprototype.cb = função (b) {this.Fc = b; return this} IbSEMPTY = IbSIb (""); Ibm = função () {this.Dc = ""; this.ji = Ibmea; this.nc = null}; Ibmprototype.Jd =! 0; Ibmprototype. $ A = D (" nc "); Ibmprototype.ya =! 0; Ibmprototype.ka = D (" Dc "); I. $ && (Ibmprototype.toString = function () {return" SafeHtml {"+ this.Dc +"} "}); Ibms = função (b) {if (b instanceof Ibm && b.constructor === Ibm && b.ji === Ibmea) return b.Dc; Ioia ("objeto esperado do tipo SafeHtml, got '" + b + a + I.da (b)); retorno "type_error: SafeHtml "};
Ibmqa = function (b) {se (b instanceof Ibm) retornar b; var c = tipoof b == v, d = null; c && b.Jd && (d = b. $ A ()); retorno Ibmwa (Ifuqa (c && b. ya? b.ka (): Seqüência (b)), d)}; IbmLr = função (b) {se (b instância de Ibm) retornar b; b = Ibmqa (b); retorno Ibmwa (IfuWb (Ibms) ), b) $ a ())}; IbmMr = função (b) {if (b instanceof Ibm) retorno b; b = Ibmqa (b); retorno Ibmwa (Ifush (Ibms (b)), b. $ a ( )); Ibmfrom = Ibmqa; IbmYe = / ^ [a-zA-Z0-9 -] + $ /;
Ibmzi = {action:! 0, cite:! 0, data:! 0, formacao:! 0, href:! 0, manifesto:! 0, poster:! 0, src:! 0}; Ibmfi = {APPLET:! 0, BASE:! 0, INCORPORADO:! 0, IFRAME:! 0, LINK:! 0, MATH:! 0, META:! 0, OBJETO:! 0, SCRIPT:! 0, ESTILO:! 0, SVG:! 0, MODELO:! 0}; Ibmcriar = função (b, c, d) {IbmPl (Seqüência (b)); retorno IbmZa (Seqüência (b), c, d)}; IbmPl = função (b) {se ( ! IbmYe.test (b)) Erro de lançamento ("Nome da etiqueta inválido <" + b + ">."); If (b.toUpperCase () no Ibmfi) Erro de lançamento ("Nome da tag <" + b + "> não é permitido para SafeHtml. ");};
Ibmuq = função (b, c, d, e) {b && I.bDs (b); var f = {}; f.src = b || nulo; f.srcdoc = c && I.bms (c); b = Ibmlc ( f, {sandbox: ""}, d); return IbmZa ("iframe", b, e)}; Ibmzq = function (b, c, d, e) {if (! IbmZi ()) Erro de lançamento ("O o navegador não suporta iframes em sandbox. "); var f = {}; f.src = b? Ibls (IblMc (b)): nulo; f.srcdoc = c || null; f.sandbox =" "; b = Ibmlc (f, {}, d); retorne IbmZa ("iframe", b, e)}; IbmZi = function () {retorne I.global.HTMLIFrameElement && "sandbox" em I.global.HTMLIFrameElement.prototype};
IbmAq = função (b, c) {IbDs (b); b = Ibmlc ({src: b}, {}, c); retorno IbmZa ("script", b)}; IbmcreateScript = function (b, c) { para (var d em c) {var e = d.toLowerCase (); se ("idioma" == e || "src" == e || "texto" == e || "tipo" == e) throw Error ('Não é possível definir' '+ e +' "atributo ');} d =" "; b = Ijconcat (b); para (e = 0; e <b.length; e ++) d + = IbPs (b [e ] b = Ibmwa (d, IhiTua); retorno IbmZa ("script", c, b)};
IbmBq = função (b, c) {c = Ibmlc ({tipo: "text / css"}, {}, c); var d = ""; b = Ijconcat (b); para (var e = 0; e <b.length; e ++) d + = IbSs (b [e]); b = Ibmwa (d, IhiTua); retorno IbmZa ("estilo", c, b)}; Ibmxq = função (b, c) {b = Ibls (IblMc (b)); (IguserAgent.A.yc () || IguserAgent.A.Ra ()) && I.fucontains (b, ";") && (b = "'" + b.replace (/' / g, "% 27") + "'"); return IbmZa ("meta", {"http-equiv": "atualizar", conteúdo: (c || 0) + "; url =" + b}) };
IbmEj = function (b, c, d) {se (d instanceof IfI) d = IfIs (d); else if ("estilo" == c.toLowerCase ()) d = IbmRj (d); else {if (/ ^ on / i.test (c)) erro de lançamento ('Atributo "' + c + '" requer o valor goog.string.Const, "' + d + '" fornecido.'); if (c.toLowerCase () em Ibmzi) se (d exemplo de IbD) d = IbDs (d); senão se (d instância de Ibl) d = Ibls (d); caso contrário, se (IO (d)) d = IblMc (d) .ka (); "Atributo" '+ c +' "na etiqueta" '+ b +' "requer goog.html.SafeUrl, goog.string.Const ou string, valor" '+ d +' "fornecido. ');} D.ya && (d = d.ka ());
return c + '= "' + Ifuqa (String (d)) + '' '}; IbmRj = função (b) {if (! I.la (b)) erro de lançamento (o atributo" estilo "requer goog.html .SafeStyle ou mapa de propriedades de estilo, '+ typeof b + "dado:" + b); b instanceof Ibw || (b = Ibwcreate (b)); return Ibws (b)}; IbmDq = function (b, c, d , e) {c = Ibmcriar (c, d, e); c.nc = b; retorno c};
Ibmconcat = função (b) {função c (b) {I.éArray (b)? Para todo (b, c): (b = Ibmqa (b), e + = Ibms (b), b = b. $ A () , d == IhiTua? d = b: b! = IhiTua & d =! & b (d = null))} var d = IthTua, e = ""; IjforEach (argumentos, c); return Ibmwa (e, d)}; Ibmqq = função (b, c) {var d = Ibmconcat (Ijslice (argumentos, 1)); d.nc = b; retorno d}; Ibmea = {}; Ibmwa = função (b, c) {retorno (novo Ibm ) .cb (b, c)}; Ibmprototype.cb = function (b, c) {this.Dc = b; this.nc = c; retorna isto};
IbmZa = função (b, c, d) {var e = nulo; var f = "<" + b + Ibmxl (b, c); I.eb (d)? IisArray (d) || (d = [d]): d = []; Iatags.zk (b.toLowerCase ())? f + = ">" :( e = Ibmconcat (d), f + = ">" + Ibms (e) + "</" + b + ">", e = e. $ a ()); (b = c & c.dir) && (e = / ^ (ltr | rtl | auto) $ / i.test (b)? IhiTua: null); return Ibmwa (f, e)}; Ibmxl = função (b, c) {var d = ""; if (c) para (var e em c) {if (! IbmYe.test (e)) Erro de lançamento (' Nome do atributo inválido "'+ e +'". '); Var f = c [e]; I.eb (f) && (d + = "" + IbmEj (b, e, f))} return d};
Ibmlc = função (b, c, d) {var e = {}, f; para (f em b) e [f] = b [f]; para (f em c) e [f] = c [f] ; para (f in d) {var g = f.toLowerCase (); se (g in b) lançar Erro (atributo 'Impossível anular' '+ g +' ", tem" '+ f +' "com valor" '+ d [f] + '' '; g em c && delete e [g]; e [f] = d [f]} return e}; IbmQm = Ibmwa ("<! DOCTYPE html>", IhiTua); IbmEMPTY = Ibmwa ( "", IhiTua); Ibmye = Ibmwa ("<br>", IhiTua); IaJ = {}; IaJKn = {Zl: "afterbegin", $ l: "afterend", pm: "beforebegin", qm: "beforeend "}; IaJOr = function (b, c, d) {b.insertAdjacentHTML (c, Ibms (d))}; IaJri = {MATH:! 0, SCRIPT:! 0, ESTILO:! 0, SVG:! 0, MODELO:! 0}; IaJmk = INYi (function () {if (eu. $ && "undefined" === tipo de documento) return! 1; var b = document.createElement ("div");innerHTML = "<div> <div> </ div> </ div>"; se (eu. $ &&! b.firstChild) retornar! 1; var c = b.firstChild.firstChild; b.innerHTML = ""; return! c.parentElement});
IaJKl = função (b, c) {se (IaJmk ()) para (; b.lastChild;) b.removeChild (b.lastChild); b.innerHTML = c}; IaJah = função (b, c) {if ( Iona && I.aJri [b.tagName.toUpperCase ()]) Erro de lançamento ("goog.dom.safe.setInnerHtml não pode ser usado para definir conteúdo de" + b.tagName + "."); IaJKl (b, Ibms (c)) } IaJQt = função (b, c) {b.outerHTML = Ibms (c)}; IaJGt = função (b, c) {c = c instância de Ibl? C: Iblta (c); IaoNi (b) .action = Ibls (c)}; IaJAt = funo (b, c) {c = c exemplo de Ibl? C: Iblta (c); IaoMi (b) .formAction = Ibls (c)};
IaJMt = função (b, c) {c = c instância de Ibl? C: Iblta (c); IaoOi (b) .formAction = Ibls (c)}; IaJSt = função (b, c) {b.style.cssText = Ibws (c)}; IaJKq = função (b, c) {b.write (Ibms (c))}; IaJyt = função (b, c) {c = c instância de Ibl? C: Iblta (c); href = Ibls (c)}; IaJLt = função (b, c) {c = c instância de Ibl? c: Iblta (c); b.src = Ibls (c)}; IaJzt = função (b, c) {c = c instanceof Ibl? c: Iblta (c); b.src = Ibls (c)}; IaJWt = função (b, c) {c = c instância de Ibl? c: Iblta (c); b.src = Ibls ( c)};
IaJEt = função (b, c) {b.src = IbDs (c)}; IaJHt = função (b, c) {b.src = IbDs (c)}; IaJJt = função (b, c) {b.src = IbDs (c)}; IaJKt = função (b, c) {b.srcdoc = Ibms (c)}; IaJNt = função (b, c, d) {b.rel = d; Ifujc (d, "folha de estilo" )? b.href = IbDs (c): b.href = c exemplo de IbD? IbDs (c): c instância de Ibl? Ibls (c): Iblta (c) .ka ()}; IaJPt = funo (b, c ) {b.data = IbDs (c)}; IaJql = função (b, c) {b.src = IbDs (c); (c = I.eg ()) && b.setAttribute ("nonce", c)} ;
IaJRt = função (b, c) {b.text = IbPs (c); (c = I.eg ()) && b.setAttribute ("nonce", c)}; IaJOt = função (b, c) {c = c instanceof Ibl? c: Iblta (c); b.href = Ibls (c)}; IaJXp = funç˜ao (b, c) {c = c instanceof Ibl? c: Iblta (c); b.assignifica (Ibls (c) )}; IaJkt = função (b, c) {c = c instância de Ibl? C: Iblta (c); b.replace (Ibls (c))}; IaJUs = função (b, c, d, e, f ) {b = b instância de Ibl? b: Iblta (b); retorno (c || janela) .open (Ibls (b), d? IfIs (d): "", e, f)}; IaJWs = funo ( b, c) {retornar b.parseFromString (Ibms (c), "text / html")};
IaJvq = function (b) {if (! / ^ Image \ /.*/g.test (b.type)) Erro de lançamento ("goog.dom.safe.createImageFromBlob aceita apenas imagem do tipo MIME /.*."); var c = window.URL.createObjectURL (b); b = nova imagem; b.onload = function () {window.URL.revokeObjectURL (c)}; b.src = c; retorno b}; Ibhb = {}; Ibhb.il = função (b, c) {retorno Ibmwa (c, nulo)}; Ibhb.rt = função (b, c) {retorno IbPGb (c)}; Ibhb.st = função (b, c) {retorno IbwHb (c)}; Ibhb.tt = função (b, c) {retorno IbSIb (c)}; Ibhb.ut = função (b, c) {retorno Iblpa (c)}; Ibhb.ru = função (b, c) {return IbDJb (c)}; Iv = {}; Iv $ s = função (b) {retornar Math.floor (Math.random () * b)}; Ivtu = função (b, c) {retorno b + Math.random () * (cb)}; Ivjq = função (b, c, d) {retornar Math.min (Math.max (b, c), d)}; IvOg = função (b, c) { b% = c; retorno 0> b * c? b + c: b}; IvAs = função (b, c, d) {retorno b + d * (cb)}; IvLs = função (b, c, d) {return Math.abs (bc) <= (d || 1E-6)};Ivhe = função (b) {retorno IvOg (b, 360)}; Ivcu = função (b) {retorno IvOg (b, 2 * Math.PI)}; Ivnh = função (b) {retorno b * Math.PI / 180}; IvBl = função (b) {return 180 * b / Math.PI};
Ivxp = função (b, c) {retorno c * Math.cos (Ivnh (b))}; Ivyp = função (b, c) {retorno c * Math.sin (Ivnh (b))}; Ivangle = função ( b, c, d, e) {retornar Ivhe (IvBl (Math.atan2 (ec, db)))}; Ivwp = função (b, c) {b = Ivhe (c) -Ivhe (b); 180 <b b = = 360: -180> = b && (b = 360 + b); retorno b}; Ivsign = função (b) {retorno 0 <b? 1: 0> b? -1: b};
IvEs = função (b, c, d, e) {d = d || função (b, c) {retorno b == c}; e = e || função (c) {retorno b [c]}; (var f = b.length, g = c.length, h = [], l = 0; l <f + 1; l ++) h [l] = [], h [l] [0] = 0; (var m = 0; m <g + 1; m ++) h [0] [m] = 0; para (l = 1; l <= f; l ++) para (m = 1; m <= g; m ++) d (b [l-1], c [m-1])? h [l] [m] = h [l-1] [m-1] +1: h [l] [m] = Math.max (h [l-1] [m], h [l] [m-1]), var r = []; l = f; para (m = g; 0 <l && 0 <m;) d (b [l -1], c [m-1])? (R.unshift (e (l-1, m-1)), l -, m -): h [l-1] [m]> h [ l] [m-1]? l -: m -; retorno r}; Ivje = função (b) {return Ijreduce (argumentos, função (b, d) {retorno b + d}, 0)};
IvQi = função (b) {return Ivje.apply (nulo, argumentos) / argumentos.length}; Ivkl = função (b) {var = argumentos.length; if (2> c) retorna 0; var d = IvQi. apply (null, arguments); return Ivje.apply (nulo, Ijmap (argumentos, função (b) {return Math.pow (bd, 2)})) / (c-1)}; Ivdu = função (b) { return Math.sqrt (Ivkl.apply (nulo, argumentos))}; Ives = função (b) {retorno éFinito (b) && 0 == b% 1}; Ivcs = função (b) {retorno éFinito (b)}; Ivks = função (b) {retorno 0 == b && 0> 1 / b};
IvDs = função (b) {se (0 <b) {var = Math.round (Math.log (b) * Math.LOG10E); retorno c- (parseFloat ("1e" + c)> b? 1: 0)} retorno 0 == b? -Infino: NaN}; Ivpt = função (b, c) {retorno Math.floor (b + (c || 2E-15))}; Ivot = função (b, c) { return Math.ceil (b- (c || 2E-15))}; IvY = função (b, c) {this.x = IX (b) b b: 0; this.y = IX (c) c c : 0}; IvYprototype.clone = function () {retornar novo IvY (this.x, this.y)}; I. $ && (IvYprototype.toString = function () {return "(" + this.x + "," + this.y + ")"}); IvYprototype.Kb = function (b) {retorno b instanceof IvY && I.vYKb (this, b)}; IvYKb = função (b, c) {retorno b == c?! 0: b && c? bx == cx && b.y == cy:! 1}; IvYJq = função (b, c) {var d = bx-cx; b = by-cy; retorno Math.sqrt (d * d + b * b )}; IvYFs = function (b) {retornar Math.sqrt (bx * b.x + by * by)};
IvYazimuth = função (b) {retorno Ivangle (0,0, bx, por)}; IvYau = função (b, c) {var d = bx-cx; b = by-cy; retorno d * d + b * b }; IvYIq = função (b, c) {retornar novo IvY (bx-cx, por-cy)}; IvYje = função (b, c) {retornar novo IvY (b.x + cx, b.y + cy) }; F = Protótipo de IvY; F.ceil = function () {this.x = Math.ceil (this.x); this.y = Math.ceil (this.y); retorne isto}; F.floor = function ( ) {this.x = Math.floor (this.x); this.y = Math.floor (this.y); retorne isto}; F.round = function () {this.x = Math.round (isto. x); this.y = Math.round (this.y); devolva isto};
F.translate = function (b, c) {b instância de IvY? (This.x + = bx, this.y + = by) :( this.x + = Número (b), I.Ub (c) && (this.y + = c)); retorna isto}; F.scale = função (b, c) {c = l.Ub (c)? c: b; this.x * = b; this.y * = c; retorna isto} ; Ivnb = função (b, c) {this.width = b; this.height = c}; Ivnb.Kb = função (b, c) {retorno b == c?! 0: b && c? B.width == c.width && b.height == c.height:! 1}; Ivnb.prototype.clone = function () {retornar novo Ivnb (this.width, this.height)}; I. $ && (Ivnb.prototype.toString = function () {return "(" + this.width + "x" + this.height + ")"}); F = Ivnb.prototype; F.aspectRatio = function () {retornar this.width / this.height}; F .Sb = function () {return! (This.width * this.height)};
F.ceil = function () {this.width = Math.ceil (this.width); this.height = Math.ceil (this.height); retorne isto}; F.floor = function () {this.width = Math.floor (this.width); this.height = Math.floor (this.height); retorna isto}; F.round = function () {this.width = Math.round (esta.width); = Math.round (this.height); retorne isto}; F.scale = function (b, c) {c = I.Ub (c)? C: b; this.width * = b; this.height * = c; devolva isto; IaDh =! 1; Iaue =! 1; IaNh = IaDh || Iaue; Iazd = função (b) {retorno b? novo Ialb (IaQa (b)): Iaoj || (Iaoj = new Ialb IaFj = function () {documento de retorno}; IaAd = função (b) {retorno IaDd (documento, b)}; IaDd = função (b, c) {retorno IO (c)? B.getElementById (c) : IaNj = função (b) {return Iadg (documento, b)} Iadg = função (b, c) {retorno IaDd (b, c)}; Iauh = IaAd; IagetElementsByTagName = função (b, c) {return (c || document) .getElementsByTagName (String (b))};
IaEd = função (b, c, d) {retorno Iarc (documento, b, c, d)} IaIj = função (b, c, d) {retorno IaCd (documento, b, c, d)} IaNf = função (b, c) {var d = c || documento; retorno Iahd (d)? d.querySelectorAll ("." + b): Iarc (documento, "*", b, c)}; IaBd = função ( b, c) {var d = c || documento; retorno (d.getElementsByClassName? d.getElementsByClassName (b) [0]: IaCd (documento, "*", b, c)) || nulo}; Iacg = função (b, c) {retornar IaBd (b, c)}; Iahd = função (b) {return! (! b.querySelectorAll ||! b.querySelector)};
Iarc = função (b, c, d, e) {b = e || b; c = c && "*"! = C? Cadeia (c) .toUpperCase (): ""; if (Iahd (b) && ( c || d)) retorna b.querySelectorAll (c + (d? "." + d: "")); if (d && b.getElementsByClassName) {b = b.getElementsByClassName (d); if (c) {e = { } para (var f = 0, g = 0, h; h = b [g]; g ++) c == h.nodeName && (e [f ++] = h); e.length = f; retorno e} retorno b } b = b.getElementsByTagName (c || "*"); if (d) {e = {}; para (g = f = 0; h = b [g]; g ++) c = h.className, typeof c .split == p && I.j.contains (c.split (/ \ s + /), d) && (e [f ++] = h); e.length = f; retorno e} retorno b};
IaCd = função (b, c, d, e) {var f = e || b, g = c && "*"! = C? Cadeia (c) .toUpperCase (): ""; return Iahd (f) && ( g || d)? f.querySelector (g + (d? "." + d: "")): Iarc (b, c, d, e) [0] || null}; Iavh = IaEd; IaPc = function (b, c) {I.object.forEach (c, função (c, e) {c && tipoof c == v && c.ya && (c = c.ka ()); "estilo" == e? b.style.cssText = c: "class" == e? b.className = c: "para" == e? b.htmlFor = c: IaBe.hasOwnProperty (e)? b.setAttribute (IaBe [e], c): IfstartsWith ( e, "aria -") || IfstartsCom (e, "data -")? b.setAttribute (e, c): b [e] = c})};
IaBe = {cellpadding: "cellPadding", cellpacing: "cellSpacing", colspan: "colSpan", frameborder: "frameBorder", altura: "altura", maxlength: "maxLength", nonce: "nonce", papel: "role" , rowspan: "rowSpan", tipo: "tipo", usemap: "useMap", valign: "vAlign", largura: "largura"}; Iaig = função (b) {return Iajg (b || janela)}; Iajg = function (b) {b = b.document; b = IaQb (b)? b.documentElement: b.body; return novo Ivnb (b.clientWidth, b.clientHeight)}; IaGj = function () {return Iaxd ( window)}; Iasr = function (b) {return Iaxd (b)};
Iaxd = function (b) {var = b.document, d = 0; if (c) {d = c.body; var e = c.documentElement; if (! E ||! D) retornar 0; b = Iajg (b) .height; if (IaQb (c) && e.scrollHeight) d = e.scrollHeight! = B? E.scrollHeight: e.offsetHeight; mais {c = e.scrollHeight; var f = e.offsetHeight; e .clientHeight! = f && (c = d.scrollHeight, f = d.offsetHeight); d = c> b? c> f? c: f: c <f? c: f}} retorno d}; Iazr = função ( b) {return Iazd ((b | | I.global || janela) .document) .Lf ()}; IaLf = function () {return IaMf (documento)};
IaMf = função (b) {var c = Idia (b); b = Iauc (b); retorno I.userAgent.aa && I.userAgent.za ("10") && b.pageYOffset! = C.scrollTop? New IvY (c .scrollLeft, c.scrollTop): novo IvY (b.pageXOffset || c.scrollLeft, b.pageYOffset || c.scrollTop)}; IaHj = function () {retorno Iayd (documento)}; Iayd = função (b) {return b.scrollingElement? b.scrollingElement:! I.userAgent.Cb && I.a.Qb (b)? b.documentElement: b.body || b.documentElement}; Iarb = function (b) {retorno b? Iauc ( b): window}; Iauc = function (b) {return b.parentWindow || b.defaultView};
Iald = função (b, c, d) {retorno Iaqf (documento, argumentos)} Iaqf = função (b, c) {var d = Cadeia (c [0]), e = c [1]; if (! Iaib.Hh && e && (e.name || e.type)) {d = ["<", d]; e.name && d.push ('nome = "', Ifqa (e.name), '"'); (e.type) {d.push ('type = "', Ifqa (e.type), '"'); var f = {}; I.object.extend (f, e); delete f.type; e = f} d.push (">"); d = d.join ("")} d = b.createElement (d); e && (IO (e)? d.className = e: I.isArray (e ) d.className = e.join (""): IaPc (d, e)); 2 <c.length && I.a.af (b, d, c, 2); retorno d};
Iaaf = função (b, c, d, e) {função f (d) {d && c.appendChild (IO (d)? B.createTextNode (d): d)} para (; e <d.length; e ++) { var g = d [e]; I.Pb (g) &&! IaNd (g)? IjforEach (IaOd (g)? Ijmh (g): g, f): f (g)}}; Iawh = Iald; IacreateElement = função (b) {return IaNa (documento, b)}; IaNa = função (b, c) {retorno b.createElement (String (c))}; IacreateTextNode = função (b) {return document.createTextNode (String b))}; Iajj = função (b, c, d) {retorno Iarf (documento, b, c, !! d)};
Iarf = função (b, c, d, e) {para (var f = IaNa (b, "TABELA"), g = f.appendChild (IaNa (b, "TBODY")), h = 0; h <c ; h ++) {para (var l = IaNa (b, "TR"), m = 0; m <d; m ++) {var r = IaNa (b, "TD"); e && I.a.ce (r, IfXe .Le); l.appendChild (r)} g.appendChild (l)} return f}; Iarq = function (b) {var c = Ijmap (argumentos, IfIs); c = Ibhb.il (IfIfrom ("Constante HTML") string, que é transformado em um Node mais tarde, então será automaticamente balanceado. "), c.join (" ")); return IaUg (c)}; IaUg = function (b) {return IaVg (documento, b) };
IaVg = função (b, c) {var d = IaNa (b, "DIV"); Iaib.ai?(IaJah(d,Ibmconcat (Ibmye, c)), d.removeChild (d.firstChild)): IaJah ( d, c); retorno Iabj (b, d)}; Iabj = função (b, c) {if (1 == c.childNodes.length) return c.removeChild (c.firstChild); para (b = b. createDocumentFragment (); c.firstChild;) b.appendChild (c.firstChild); retorno b}; Iagk = function () {retorno IaQb (documento)}; IaQb = função (b) {retorno IaNh? Iaue: "CSS1Compat" == b.compatMode}; IacanHaveChildren = function (b) {se (b.nodeType! = Iaga.Ja) retorna! 1; switch (b.tagName) {caso "APPLET": caso "AREA": caso "BASE" : caso "BR": caso "COL": caso "COMMAND": caso "EMBED": caso "FRAME": caso "HR": caso "IMG": caso "INPUT": caso "IFRAME": caso "ISINDEX" : caso "KEYGEN":caso "LINK": caso "NOFRAMES": caso "NOSCRIPT": caso "META": caso "OBJECT": caso "PARAM": caso k: caso "SOURCE": caso "STYLE": caso "TRACK": caso " WBR ": return! 1} return! 0};
IaappendChild = function (b, c) {b.appendChild (c)}; Iaappend = function (b, c) {Iaaf (IaQa (b), b, argumentos, 1)}; Ia $ d = função (b) { para (var c; c = b.firstChild;) b.removeChild (c)}; Iapg = função (b, c) {c.parentNode && c.parentNode.insertBefore (b, c)}; Iaog = função (b, c ) {c.parentNode && c.parentNode.insertBefore (b, c.nextSibling)}; Iang = function (b, c, d) {b.insertBefore (c, b.childNodes [d] || null)}; IaremoveNode = function (b) {return b && b.parentNode? b.parentNode.removeChild (b): nulo};
IaTg = função (b, c) {var d = c.parentNode; d && d.replaceChild (b, c)}; IaCf = função (b) {var c, d = b.parentNode; if (d && d.nodeType! = Iaga .Th) {if (b.removeNode) return b.removeNode (! 1); para (; c = b.firstChild;) d.insertBefore (c, b); retorno IaremoveNode (b)}}; IaJf = function ( b) {return Iaib.Ih && void 0! = b.children? b.children: Ijfilter (b.childNodes, função (b) {retorno b.nodeType == Iaga.Ja})}; IaOf = função (b) {retorno IX (b.firstElementChild)? B.firstElementChild: Iasc (b.firstChild,! 0)};
IaSf = function (b) {retorno IX (b.lastElementChild)? B.lastElementChild: Iasc (b.lastChild,! 1)}; IaUf = função (b) {retorno IX (b.nextElementSibling)? B.nextElementSibling: Iasc (b.nextSibling,! 0)}; Iaag = função (b) {retorno IX (b.previousElementSibling)? b.previousElementSibling: Iasc (b.previousSibling,! 1)}; Iasc = function (b, c) {para (; b && b.nodeType! = Iaga.Ja;) b = c? b.nextSibling: b.previousSibling; retorno b};
IaVf = function (b) {if (! B) retorna null; if (b.firstChild) retorna b.firstChild; para (; b &&! B.nextSibling;) b = b.parentNode; retorno b? B.nextSibling: null }; Iabg = função (b) {if (! B) return null; if (! B.previousSibling) return b.parentNode; para (b = b.previousSibling; b && b.lastChild;) b = b.lastChild; retorno b }; IaNd = função (b) {retorno I.la (b) && 0 <b.nodeType}; IaLd = função (b) {retorno I.la (b) && b.nodeType == Iaga.Ja}; IaIg = função (b) {retorno I.la (b) && b.janela == b};
Ia $ f = função (b) {var c; if (Iaib.Jh &&! (I.userAgent.aa && I.userAgent.za ("9") &&! I.userAgent.za ("10") && I.global.SVGElement && b instanceof I.global.SVGElement) && (c = b.parentElement)) return c; c = b.parentNode; retorno IaLd (c)? c: nulo}; Iacontains = função (b, c) {if (! b | |! c) return! 1; if (b.contains && c.nodeType == Iaga.Ja) retorna b == c || b.contains (c); if ("indefinido"! = typeof b.compareDocumentPosition) retorna b = = c || !! (b.compareDocumentPosition (c) & 16); para (; c && b! = c;) c = c.parentNode; retorno c == b};
Iakf = function (b, c) {se (b == c) retornar 0; se (b.compareDocumentPosition) retornar b.compareDocumentPosition (c) & 2? 1: -1; if (I.userAgent.aa &&! I.userAgent .Rb (9)) {se (b.nodeType == Iaga. $ C) return-1; if (c.nodeType == Iaga. $ C) retorne 1} se ("sourceIndex" em b || b.parentNode && "sourceIndex" em b.parentNode) {var d = b.nodeType == Iaga.Ja, e = c.nodeType == Iaga.Ja; if (d && e) retorna b.sourceIndex-c.sourceIndex; var f = b. parentNode, g = c.parentNode; retorno f == g? Iamf (b, c):! d && I.a.contains (f, c)? - 1 * Ialf (b, c):! e && I.a.contains ( g, b)? Ialf (c,
b): (d? b.sourceIndex: f.sourceIndex) - (e? c.sourceIndex: g.sourceIndex)} e = IaQa (b); d = e.createRange (); d.selectNode (b); d .collapse (! 0); b = e.createRange (); b.selectNode (c); b.collapse (! 0); retorno d.compareBoundaryPoints (I.global.Range.START_TO_END, b)}; Ialf = função (b, c) {var d = b.parentNode; se (d == c) return-1; para (; c.parentNode! = d;) c = c.parentNode; retorno Iamf (c, b)}; Iamf = função (b, c) {para (; c = c.previousSibling;) if (c == b) return-1; return 1};
Iayf = function (b) {var c, d = argumentos.length; if (! D) retorna null; if (1 == d) retorna argumentos [0]; var e = [], f = Infinito; = 0; c <d; c ++) {para (var g = [], h = argumentos [c]; h;) g.unshift (h), h = h.parentNode; e.push (g); f = Math.min (f, g.length)} g = null; para (c = 0; c <f; c ++) {h = e [0] [c]; para (var l = 1; l <d; l ++ ) if (h! = e [l] [c]) retorno g; g = h} retorno g}; IaQa = função (b) {retorno b.nodeType == Iaga. $ c? b: b.ownerDocument || b.document}; IaPf = function (b) {return b.contentDocument || b.contentWindow.document};
IaQf = function (b) {try {retornar b.contentWindow || (b.contentDocument? Iarb (b.contentDocument): nulo)} catch (c) {} retornar nulo}; Iace = function (b, c) {se ("textContent" em b) b.textContent = c; else if (b.nodeType == Iaga.ec) b.data = Cadeia (c); else if (b.firstChild && b.firstChild.nodeType == Iaga.ec) {for (; b.lastChild! = b.firstChild;) b.removeChild (b.lastChild); b.firstChild.data = Cadeia (c)} mais {Ia $ d (b); var d = IaQa (b) b.appendChild (d.createTextNode (String (c)))}};
IaZf = function (b) {if ("outerHTML" em b) retorna b.outerHTML; var c = IaQa (b); c = IaNa (c, "DIV"); c.appendChild (b.cloneNode (! 0) ); return c.innerHTML}; Iazf = function (b, c) {var d = []; return Iasd (b, c, d,! 0)? d [0]: void 0}; IaAf = funo (b c) {var d = []; Iasd (b, c, d,! 1); retorno d}; Iasd = função (b, c, d, e) {se (null! = b) para (b = b.firstChild; b;) {se (c (b) && (d.push (b), e) || Iasd (b, c, d, e)) retornar! 0; b = b.nextSibling} retornar! 1}; IaUe = {SCRIPT: 1, ESTILO: 1, HEAD: 1, IFRAME: 1, OBJETO: 1}; IACC = {IMG: "", BR: "\ n"};
IaMd = função (b) {retorno Ialg (b) && I.a.Gg (b)}; IaZg = função (b, c) {c ?b.tabIndex = 0: (b.tabIndex = -1, b.removeAttribute ("tabIndex")); Iavg = função (b) {var c; retorno (c = IaTk (b) ?! b.disabled && (! Ialg (b) || IaGg (b)): IaMd (b)) && I.userAgent.aa? Ia $ j (b): c}; Ialg = function (b) {retorno I.userAgent.aa &&! I.userAgent.za ("9")? (B = b.getAttributeNode ("tabindex "), I.eb (b) && b.specified): b.hasAtributo (" tabindex ")}; IaGg = função (b) {b = b.tabIndex; retorno I.Ub (b) && 0 <= b && 32768> b };
IaTk = function (b) {retorno "A" == b.tagName || "INPUT" == b.tagName || "TEXTAREA" == b.tagName || "SELECT" == b.tagName || "BOTÃO "== b.tagName}; Ia $ j = function (b) {b =! I.Ca (b.getBoundingClientRect) || I.userAgent.aa && null == b.parentElement? {altura: b.offsetHeight, largura: b.offsetWidth}: b.getBoundingClientRect (); retorno I.eb (b) && 0 <b.height && 0 <b.width};
Iatc = function (b) {se (Iaib.ze && null! == b && "innerText" em b) b = Ifaj (b.innerText); senão {var c = []; IaGd (b, c,! 0); = c.join ("")} b = b.replace (/ \ xAD / g, "") .replace (/ \ xAD / g, ""); b = b.replace (/ \ u200B / g, " "); Iaib.ze || (b = b.replace (/ + / g," "));" "! = B && (b = b.replace (/ ^ \ s * /," ")); b}; IaCr = função (b) {var c = []; IaGd (b, c,! 1); retorno c.join ("")};
IaGd = function (b, c, d) {se (! (B.nodeName na IaUe)) if (b.nodeType == Iaga.ec) d? C.push (Cadeia (b.nodeValue) .replace (/ ( \ r \ n | \ r | \ n) / g, "")): c.push (b.nodeValue), senão se (b.nodeName em Iacc) c.push (Iacc [b.nodeName]); else para (b = b.firstChild; b;) IaGd (b, c, d), b = b.nextSibling}; IaXf = função (b) {retorno Iatc (b) .comprimento}; IaYf = função (b, c ) {c = c || IaQa (b) .body; para (var d = []; b && b! = c;) {para (var e = b; e = e.previousSibling;) d.unshift (Iatc (e )); b = b.parentNode} return IftrimLeft (d.join ("")). replace (/ + / g, "") .length};
IaWf = função (b, c, d) {b = [b]; para (var e = 0, f = nulo; 0 <comprimento leve && e <c;) se (f = b.pop (),! (F .nodeName em IaUe)) if (f.nodeType == Iaga.ec) {var g = f.nodeValue.replace (/ (\ r \ n | \ r | \ n) / g, ""). substituir (/ + / g, ""); e + = g.length} mais if (f.nodeName em IACC) e + = IACC [f.nodeName] .length; else para (g = f.childNodes.length-1; 0 <= g;) b.push (f.childNodes [g]); I.la (d) && (d.ct = f? f.nodeValor.length + ce-1: 0, d.node = f) ; retorno f};
IaOd = function (b) {se (b && typeof b.length == u) {if (I.la (b)) retornar typeof b.item == p || typeof b.item == y; if (I.Ca (b)) return typeof b.item == p} return! 1}; Iavd = function (b, c, d, e) {if (! c &&! d) return nulo; var f = c? String (c) .toUpperCase (): null; retorno Iaud (b, function (b) {return (! f || b.nodeName == f) && (! d || IO (b.className) && I.j.contains (b. className.split (/ \ s + /), d)),, 0, e)}; IaGf = function (b, c, d) {retorno Iavd (b, null, c, d)};
Iaud = função (b, c, d, e) {b &&! D && (b = b.parentNode); para (d = 0; b && (nulo == e || d <= e);) {se (c ( b)) retorno b; b = b.parentNode; d ++} retorno nulo}; IaFf = função (b) {try {var = b & b.activeElement; retorno c & & c.nodeName? c: nulo} captura (d) {retorno nulo }}; IaAr = function () {var b = Iarb (); retorno IX (b.devicePixelRatio)? B.devicePixelRatio: b.matchMedia? IaAc (3) || IaAc (2) || IaAc (1.5) || IaAc (1) ||, 75: 1};
IaAc = função (b) {return Iarb (). MatchMedia ("(min-resolução:" + b + "dppx), (min-moz-device-pixel-ratio:" + b + "), (resolução mínima: "+ 96 * b +" dpi) "). Corresponde? B: 0}; IaIf = função (b) {retorno b.getContext (" 2d ")}; Ialb = função (b) {this.Z = b || I.global.document || documento}; F = Ialb.prototype; F.zd = Iazd; F.Fj = D ("Z"); F.Ad = função (b) {return IaDd (this.Z, b )}; F.Nj = function (b) {return Iadg (this.Z, b)}; F.uh = Ialb.prototype.Ad; F.getElementsByTagName = function (b, c) {retorno (c || .Z) .getElementsByTagName (String (b))};
F.Ed = função (b, c, d) {retorno Iarc (this.Z, b, c, d)}; F.Ij = função (b, c, d) {retorno IaCd (this.Z, b, c, d)}; F.Nf = função (b, c) {retorno IaNf (b, c || this.Z)}; F.Bd = função (b, c) {retorno IaBd (b, c || this.Z)}; F.cg = function (b, c) {return Iacg (b, c || this.Z)}; F.vh = Ialb.prototype.Ed; F.Pc = IaPc; F.ig = function (b) {return Iaig (b || this.rb ())}; F.Gj = function () {retorno Iaxd (this.rb ())}; F.ld = função (b, c, d ) {return Iaqf (this.Z, argumentos)}; F.wh = Ialb.prototype.ld; F.createElement = function (b) {return IaNa (this.Z, b)};
F.createTextNode = function (b) {retornar this.Z.createTextNode (String (b))}; F.jj = function (b, c, d) {retorno Iarf (this.Z, b, c, !! d )}; F.Ug = function (b) {retorno IaVg (this.Z, b)}; F.gk = function () {retorno IaQb (this.Z)}; F.rb = function () {retorno Iauc (this.Z)}; F.Hj = function () {retorno Iayd (this.Z)}; F.Lf = function () {retorno IaMf (this.Z)}; F.Ff = function (b) { return IaFf (b || this.Z)}; F.appendChild = IaappendChild; F.append = Iaappend; F.canHaveChildren = IacanHaveChildren; F. $ d = Ia $ d; F.pg = Iapg; F.og = Iaog Fng = Iang;
F.removeNode = IaremoveNode; F.Tg = IaTg; F.Cf = IaCf; F.Jf = IaJf; F.Of = IaOf; F.Sf = IaSf; F.Uf = IaUf; F.ag = Iaag; F. Vf = IaVf; F.bg = Iabg; F.Nd = IaNd; F.Ld = IaLd; F.Ig = IaIg; F. $ f = Ia $ f; F.contains = Iacontains; F.kf = Iakf; F yf = I ff; F.Qa = IaQa; F.Pf = IaPf; F.Qf = IaQf; F.ce = Iace; F.Zf = IaZf; F.f = Iazf; F.Af = IaAf; F.Mf = IaMd; F.Zg = IaZg; F.vg = Iavg; F.tc = Iatc; F.Xf = IaXf; F.Yf = IaYf; F.Wf = IaWf; F.Od = IaOd; F.vd = Iavd F.Gf = IaGf; F.ud = Iaud; F.If = IaIf; I.Sg = {}; I.Sg.Bo = C (); I.Thenable = C (); I.Thenable.prototype. então = C (); I.Thenable.Ie = "$ goog_Thenable"; I.Thenable. $ e = function (b) {b.prototipo [I.Thenable.Ie] =! 0}; I.Thenable.wg = function (b) {if (! b) return! 1; tente {return !! b [I.Thenable.Ie]} pegar (c) {return! 1}}; I.Promise = function (b, c) { this.ca = I.Promise.U.Aa; this.ma = void 0; this.ob = this.Ma = this.fa = null; this.qd =! 1; 0 <I.Promise.Wa? this. Sc = 0: 0 == I. Promessa.Wa && (this.vc =! 1); I.Promise.Ea && (this.ge = [], L (isto, Error ("criado")), this.tf = 0); if (b! = I.fb tente {var d = isto; b.call (c, função (b) {M (d, I.Promise.U.Ka, b)}, função (b) {if (I. $ &&! (b instanceof I.Promise.kb)) tente {if (b Erro de ocorrência) lançar b; lançar Erro ("Promise rejected.");} Catch (f) {} M (d, I.Promise.U.oa, b)} }} catch (e) {M (isto, I.Promise.U.oa, e)}}; I.Promise.Ea =! 1;
I.Promise.Wa = 0; I.Promise.U = {Aa: 0, Fh: 1, Ka: 2, oa: 3}; I.Promise.Ae = function () {this.next = this.context = this.ub = this.Xb = this.Xa = null; this.fc =! 1}; I.Promise.Ae.prototype.reset = function () {this.context = this.ub = this.Xb = isso. Xa = null; this.fc =! 1}; I.Promise.Zc = 100; I.Promise.Mb = novo I.async.ac (function () {retornar novo I.Promise.Ae}, função (b) {b.reset ()}, I.Promise.Zc); I.Promise.Hf = função (b, c, d) {var e = I.Promise.Mb.get (); e.Xb = b; e .ub = c; e.context = d; return e}; I.Promise.al = função (b) {I.Promise.Mb.put (b)};
I.Promise.resolve = function (b) {se (b instanceof I.Promise) retornar b; var c = novo I.Promise (I.fb); M (c, I.Promise.U.Ka, b); return c}; I.Promise.reject = function (b) {retornar novo I.Promise (função (c, d) {d (b)})}; I.Promise.Kc = função (b, c, d) {I.Promise.Ng (b, c, d, nulo) || I.async.R (I.gb (c, b))}; I.Promise.race = função (b) {retornar novo I.Promise (função (c, d) {b.length || c (void 0); para (var e = 0, f; e <b.length; e ++) f = b [e], I.Promise.Kc (f ,CD)})};
I.Promise.all = function (b) {retornar novo I.Promise (função (c, d) {var e = b.length, f = []; se (e) para (var g = function (b, d ) {e -; f [b] = d; 0 == e & c (f)}, h = função (b) {d (b)}, l = 0, m; l <b.length; l ++) m = b [l], I.Promise.Kc (m, I.gb (g, l), h), senão c (f)})}; I.Promise.vp = function (b) {retorno novo I. Promise (função (c) {var d = b.length, e = []; if (d) para (var f = função (b, f, g) {d -; e [b] = f? :! 0, valor: g}: {Dj:! 1, razão: g}; 0 == d & c (e)}, g = 0, h; g <b.length; g ++) h = b [g], I.Promise.Kc (h, I.gb (f, g, 0), I.gb (f, g, 1)), senão c (e)})};
I.Promise.Wq = function (b) {retornar novo I.Promise (função (c, d) {var e = b.length, f = []; if (e) para (var g = function (b) { c (b)}, h = função (b, c) {e -; f [b] = c; 0 == e & d (f)}, l = 0, m; l <b.length; l ++) m = b [l], I.Promise.Kc (m, g, I.gb (h, l)); senão c (void 0)})}; I.Promise.zu = function () {var b, c , d = novo I. Promise (função (d, f) {b = d; c = f}); retornar novo I.Promise.ii (d, b, c)}; I.Promise.prototype.then = function (b, c, d) {I.Promise.Ea && L (isto, Erro ("then")); retorno ca (isso, I.Ca (b)? b: nulo, I.Ca (c)? c: null , d)}; I.Thenable. $ e (I.Promise);
I.Promise.prototype.cancel = function (b) {this.ca == I.Promise.U.Aa && I.async.R (function () {var c = novo I.Promise.kb (b); N (este c)}, isto)}; função N (b, c) {se (b.ca == I.Promise.U.Aa) if (b.fa) {var d = b.fa; if (d. Ma) {para (var e = 0, f = nulo, g = nulo, h = d.Ma; h && (h.fc || (e ++, h.Xa == b && (f = h),! (F && 1 < e)); h = h.next) f || (g = h); f && (d.ca == I.Promise.U.Aa && 1 == e? N (d, c): (g? = g, e.next == d.ob && (d.ob = e), e.next = e.next.next): O (d), P (d, f, I.Promise.U.oa, c )))} b.fa = null} mais M (b, I.Promise.U.oa, c)}
função Q (b, c) {b.Ma || b.ca! = I.Promise.U.Ka && b.ca! = I.Promise.U.oa || R (b); b.ob? b.ob .next = c: b.Ma = c; b.ob = c} função ca (b, c, d, e) {var f = I.Promise.Hf (nulo, nulo, nulo); f.Xa = novo I.Promise (função (b, h) {f.Xb = função c (d) {try {var = c.call (e, d); b (f)} captura (r) {h (r) }}: b; f.ub = d? função (c) {try {var = d.call (e, c); IX (f) &&c instanceof I.Promise.kbh (c): b ( f)} captura (r) {h (r)}}: h}); f.Xa.fa = b; Q (b, f); retorno f.Xa} I.Promise.prototype.Fl = function (b ) {this.ca = I.Promise.U.Aa; M (isto, I.Promise.U.Ka, b)};
I.Promise.prototype.Gl = função (b) {this.ca = I.Promise.U.Aa; M (isto, I.Promise.U.oa, b)}; função M (b, c, d) {b.ca == I.Promise.U.Aa && (b === d && (c = I.Promise.U.oa, d = new TypeError ("Promessa não pode resolver para si mesmo")), b.ca = I .Promise.U.Fh, I.Promise.Ng (d, b.Fl, b.Gl, b) || (b.ma = d, b.ca = c, b.fa = null, R (b) , c! = I.Promise.U.oa || d instanceof I.Promise.kb || I.Promise.Gi (b, d)))}
I.Promise.Ng = função (b, c, d, e) {se (b instanceof I.Promise) retornar I.Promise.Ea && L (b, Erro ("then")), Q (b, I.Promise. Hf (c || I.fb, d || null, e)), 0, se (I.Thenable.wg (b)) retornar b.then (c, d, e), 0; se (I .la (b)) tente {var f = b.then; se (I.Ca (f)) retornar I.Promise.Dl (b, f, c, d, e), 0} catch (g) { return d.call (e, g), 0} return! 1}; I.Promise.Dl = function (b, c, d, e, f) {função g (b) {l || (l =! 0, e.call (f, b)}} função h (b) {l || (l =! 0, d.call (f, b))} var l =! 1; tente {c.call (b , h, g)} captura (m) {g (m)}}; função R (b) {b.qd || (b.qd =! 0, I.async.R (b.xj, b)) }
função O (b) {var c = nula; b.Ma && (c = b.Ma, b.Ma = c.next, c.next = null); b.Ma || (b.ob = null); c} I.Promise.prototype.xj = function () {para (var b; b = O (este);) I.Promise.Ea && this.tf ++, P (isto, b, this.ca, this.ma); this.qd =! 1};
função P (b, c, d, e) {se (d == I.Promise.U.oa && c.ub &&! c.fc) if (0 <I.Promise.Wa) para (; b && b.Sc; b = b.fa) I.global.clearTimeout (b.Sc), b.Sc = 0; else if (0 == I.Promise.Wa) para (; b && b.vc; b = b.fa) b.vc = ! 1; if (c.Xa) c.Xa.fa = null, I.Promise.rg (c, d, e); senão tente {c.fc? C.Xb.call (c.context): I. Promise.rg (c, d, e)} captura (f) {I.Promise.wc.call (nulo, f)} I.Promise.al (c)} I.Promise.rg = função (b, c, d) {c == I.Promise.U.Ka? b.Xb.call (b.context, d): b.ub && b.ub.call (b.contexto, d)};
função L (b, c) {se (I.Promise.Ea && I.O (c.stack)) {var d = c.stack.split ("\ n", 4) [3]; c = c.mensagem; c + = Array (11-c.length) .join (""); b.ge.push (c + d)}} função S (b, c) {se (I.Promise.Ea && c && I.O (c.stack) ) (& = b.ge.length) {para (var d = ["Promise trace:"], e = b; e; e = e.fa) {para (var f = b.tf; 0 <= f; f- -) d.push (e.ge [f]); d.push ("Valor: [" + (e.ca == I.Promise.U.oa? "REJEITADO": "CUMPRIDO") + "] < "+ String (e.ma) +"> ")} c.stack + =" \ n \ n "+ d.join (" \ n ")}}
I.Promise.Gi = função (b, c) {0 <I.Promise.Wa? B.Sc = I.global.setTimeout (função () {S (b, c); I.Promise.wc.call ( null, c)}, I.Promise.Wa): 0 == I.Promise.Wa && (b.vc =! 0, I.async.R (função () {b.vc && (S (b, c), I.Promise.wc.call (null, c))}))}; I.Promise.wc = I.async.jh; I.Promise.Ut = function (b) {I.Promise.wc = b}; I.Promise.kb = function (b) {I.debug.Error.call (isto, b)}; I.bb (I.Promise.kb, I.debug.Error); I.Promise.kb.prototype. name = "cancelar"; I.Promise.ii = function (b, c, d) {this.Sg = b; this.resolve = c; this.reject = d};
 Partes deste código são do MochiKit, recebidas por
 Os Autores de Encerramento sob a licença do MIT. Todos os outros códigos são direitos autorais
 2005-2009 Os Autores de Encerramento. Todos os direitos reservados.
* /
I.async.C = function (b, c) {this.Oc = []; this.Rb = b; this.uf = c || null; this.sb = this.pb =! 1; this.ma = void 0; this.de = this.Vi = this.gd =! 1; this.Rc = 0; this.fa = null; this.gc = 0; I.async.C.Ea && (this.kd = null, Error.captureStackTrace && (b = {pilha: ""}, Error.captureStackTrace (b, I.async.C), tipo de b.stack == y && (this.kd = b.stack.replace (/ ^ [^ \ n ] * \ n /, ""))))}; I.async.C.ti =! 1; I.async.C.Ea =! 1; F = I.async.C.prototype;
F.cancel = function (b) {if (this.pb) this.ma instanceof.async.C&&.ma.cancel (); else {if (this.fa) {var = this.fa; delete isto. b.c ciel (b): (c.gc -, 0> = c.gc & c.cancel ())} this.Rg this.Rg.call (this.uf, isso): this.de =! 0; this.pb || this.Pa (novo I.async.C.jb (this))}}; F.pf = function (b, c) {this.gd =! 1; T (isto, b, c)}; função T (b, c, d) {b.pb =! 0; b.ma = d; b.sb =! c; U (b)} função V (b) {se (b .pb) {if (! b.de) lançar novo I.async.C.Yb (b); b.de =! 1}} F.Eb = função (b) {V (isto); T (isto, ! 0, b)}; F.Pa = função (b) {V (isto); W (isto, b); T (isto,! 1, b)};
função W (b, c) {I.async.C.Ea && b.kd && I.la (c) & & c.stack && / ^ [^ \ n] + (\ n [^ \ n] +) teste de + / (c. stack) && (c.stack = c.stack + "\ nPRODUÇÃO DEFERIDA: \ n" + b.kd)} função X (b, c, d) {retorno Y (b, c, nulo, d)} função da ( b, c) {Y (b, nulo, c, void 0)} função Y (b, c, d, e) {b.Oc.push ([c, d, e]); b.pb && U (b) ; return b} F.then = função (b, c, d) {var e f, g = novo I.Promise (função (b, c) {e = b; f = c}); Y (isto, e, function (b) {b instanceof.async.C.jb? g.cancel (): f (b)}); return g.then (b, c, d)}; I.Thenable. $ e ( I.async.C);
I.async.C.prototype.Xi = function () {var b = novo I.async.C; Y (isto, b.Eb, b.Pa, b); b.fa = este; este.gc ++; retorno b); função Z (b) {retorno Ijsome (b.Oc, função (b) {retorno I.Ca (b [1])})}
função U (b) {b.Rc && b.pb && Z (b) && (I.async.C.Ll (b.Rc), b.Rc = 0); b.fa && (b.fa.gc -, excluir b .fa); para (var c = b.ma, d =! 1, e =! 1; b.Oc.length &&! b.gd;) {var f = b.Oc.shift (), g = f [ 0], h = f [1]; f = f [2]; se (g = b.sb? H: g) tente {var l = g.call (f || b.uf, c); IX ( l) && (b.sb = b.sb && (l == c || l instanceof Error), b.ma = c = l), se (I.Thenable.wg (c) || ​​tipoof I.global.Promise === p && c instanceof I.global.Promise) e =! 0, b.gd =! 0} captura (m) {c = m, b.sb =! 0, W (b, c), Z (b) || (d =! 0)}} b.ma = c; e? (e = I.bind (b.pf, b,! 0), l = I.bind (b.pf, b,! 1) c instanceof I.async.C? (Y (c, e, l), c.Vi =! 0):
c.then (e, l)): I.async.C.ti && c instanceof Erro &&! (c instanceof I.async.C.jb) && (d = b.sb =! 0); d && (b.Rc = I .async.C.nl (c)}} I.async.C.hh = função (b) {var c = novo I.async.C; c.Eb (b); retorno c}; .gr = function (b) {var c = novo I.async.C; b.then (função (b) {c.Eb (b)}, função (b) {c.Pa (b)}); c); I.async.C.ia = function (b) {var = novo I.async.C; c.Pa (b); retorno c}; I.async.C.fq = function () {var b = novo I.async.C; b.cancel (); retorno b};
I.async.C.yu = function (b, c, d) {retorno b instanceof I.async.C? X (b.Xi (), c, d): X (i.async.C.hh (b ), c, d)}; I.async.C.Yb = função () {I.debug.Error.call (this)}; I.bb (I.async.C.Yb, I.debug.Error) ; I.async.C.Yb.prototype.message = "Adiado já foi acionado"; I.async.C.Yb.prototype.name = "AlreadyCalledError"; I.async.C.jb = function () {I. debug.Error.call (this)}; I.bb (I.async.C.jb, I.debug.Error); I.async.C.jb.prototype.message = "Adiada foi cancelada"; I.async .C.jb.prototype.name = "CanceledError";
I.async.C.Ee = function (b) {this.Ob = I.global.setTimeout (I.bind (this.ih, isso), 0); this.vj = b}; I.async.C. Ee.prototype.ih = function () {excluir I.async.C.Lb [this.Ob]; throw this.vj;}; I.async.C.Lb = {}; I.async.C.nl = função (b) {b = novo I.async.C.Ee (b); I.async.C.Lb [b.Ob] = b; retorno b.Ob}; I.async.C.Ll = função ( b) {var c = l.async.C.Lb [b]; c && (I.global.clearTimeout (c.Ob), exclua I.async.C.Lb [b])}; I.async.C. Sp = function () {var b = l .async.C.Lb, c; para (c em b) {var d = b [c]; I.global.clearTimeout (d.Ob); d.ih () IGH = = "fechamento_verificação"; IGHQh = 5E3; IGHbe = []; IGHjl = função (b, c) {função d () {var e = b.shift () ; e = IGHLc (e, c); b.length && Y (e, d, d, void 0); retorne e} if (! b.length) retorne I.async.C.hh (nulo); var e = IGHbe .length; Ijextend (IGHbe, b); if (e) retorna IGHXg; b = IGHbe; IGHXg = d (); retorno IGHXg};
IGHLc = função (b, c) {var d = c || {}; c = d.documento || documento; var e = IbDs (b), f = IacreateElement (k), g = {Yg: f, lh : void 0}, h = novo I.async.C (IGH $ i, g), l = null, m = l.eb (d.timeout)? d.timeout: IGHQh; 0 <m && (l = janela. setTimeout (function () {IGHkc (f,! 0); h.Pa (novo IGHError (IGH $ b.TIMEOUT, "Tempo limite atingido para o script de carregamento" + e))}, m), g.lh = l); f.onload = f.onreadystatechange = function () {f.readyState && "carregado"! = f.readyState && "completo"! = f.readyState || (IGHkc (f, d.kq ||! 1, l), h .Eb (null)); f.onerror = function () {IGHkc (f,
! 0, l); h.Pa (novo IGHError (IGH $ b.bi, "Erro ao carregar o script" + e)); g = d.atributos || {}; I.object.extend (g, { tipo: z, charset: "UTF-8"}); IaPc (f, g); IaJql (f, b); IGHPj (c) .appendChild (f); return h};
IGHqt = função (b, c, d) {Iglobal [IGHbd] || (I.global [IGHbd] = {}); var e = I.global [IGHbd], f = IbDs (b); IX (e [c])) return I.async.C.ia (novo IGHError (IGH $ b.Ei, "Objeto de verificação" + c + "já definido.")); B = IGHLc (b, d); var g = novo I.async.C (I.bind (b.cancel, b)); X (b, funï¿½o () {var b = e [c]; IX (b)? (g.Eb (b), delete e [c]): g.Pa (novo IGHError (IGH $ b.Di, "Script" + f + "carregado, mas objeto de verificação" + c + "não foi definido."))}); da (b, function (b) {IX (e [c]) && delete e [c]; g.Pa (b)}); retorno g};
IGHPj = function (b) {var = IagetElementsByTagName ("HEAD", b); return! C || IjSb (c)? B.documentElement: c [0]}; IGH $ i = function () {se (isto && este .Yg) {var b = this.Yg; b && b.tagName == k && I.GHkc (b,! 0, this.lh)}}; IGHkc = função (b, c, d) {I.eb (d) && I .global.clearTimeout (d); b.onload = I.fb; b.onerror = I.fb; b.onreadystatechange = I.fb; c && window.setTimeout (função () {IaremoveNode (b)}, 0)}; IGH $ b = {bi: 0, TIMEOUT: 1, Di: 2, Ei: 3};
IGHError = função (b, c) {var d = "erro do Jsloader (código #" + b + ")"; c && (d + = ":" + c); I.debug.Error.call (isto, d); .code = b}; I.bb (IGHError, I.debug.Error); var google = {F: {}}; google.FL = {}; google.FLFa = {}; google.FLFa.kh = 3E4 ; google.FLFa.Gs = function (b, c) {retorno {formato: b, Hi: c}}; google.FLFa.Sj = função (b) {retorno IbDformat (b.format, b.Hi)}; google.FLFa.load = function (b, c) {b = formato IbD (b, c); var d = IGHLc (b, {tempo: google.FLFa.kh, atributos: {async:! 1, adiar:! 1 }}); return new Promise (função (b) {X (d, b)})};
google.FLFa.Bs = function (b) {b = Ijmap (b, google.FLFa.Sj); if (IjSb (b)) retorna Promise.resolve (); var c = {timeout: google.FLFa.kh, atributos: {async:! 1, adiar:! 1}}, d = [];! I.userAgent.aa || I.userAgent.za (11)? IjforEach (b, funo (b) {d.push ( IGHLc (b, c))}): d.push (IGHjl (b, c)); retorno Promise.all (Ijmap (d, função (b) {return new Promise (função (c) {retorno X (b, c)})}))}; google.FLV = {}; if (I.ab (q)) erro de lançamento ("Google Charts loader.js só pode ser carregado uma vez."); google.FLVQl = {1: "1.0", "1.0": "atual", "1.1": "próximo", 41: w, 42: w, 43: w, 44: w, 46: "46.1", "46.1": "46.2", anterior: "45.2", atual: "46", a seguir: "46.2"}; google.FLVOk = function (b) {var = b, d = b.match (/ ^ testing - /); d && (c = c.replace (/ ^ testing - /, "")); b = c; do {var e = google.FLV.Ql [c]; e && (c = e)} enquanto (e); d = (d? "Teste -": "") + c; retorno {versão: c == w? B: d, Hk: d}}; google.FLVrh = null;
google.FLVGk = function (b) {var = google.FLVOk (b), d = IfIfrom ("https://www.gstatic.com/charts/%{version}/loader.js"); retorne o google. FLFa.load (d, {versão: c.Hk}). Then (function () {var d = I.ab ("google.charts.loader.VersionSpecific.load") || I.ab ("google.charts .loader.publicLoad ") || I.ab (" google.charts.versionSpecific.load "); if (! d) erro de lançamento (" Versão inválida: "+ b); google.FLVrh = função (b) {b = d (c.version, b); if (null == b || null == b.then) {var e = I.ab ("google.charts.loader.publicSetOnLoadCallback") || I.ab (" google.charts.versionSpecific.setOnLoadCallback ");
b = new Promise (função (b) {e (b)}); b.then = e} retornar b}})}; google.FLVQd = null; google.FLVmc = nulo; google.FLVEk = função (b, c) {if (! google.FLVQd) {if (c.enableUrlSettings && window.URLSearchParams) tente {b = (new URLSearchParams (top.location.search)). get ("gráficos-versão") || b} catch (d {console.info ("Falha ao obter a versão do gráfico do URL superior", d)} google.FLVQd = google.FLVGk (b)} retornar google.FLVmc = google.FLVQd.then (function () {return google. FLVrh (c)})};
google.FLVpl = function (b) {if (! google.FLVmc) erro de lançamento ("Deve chamar google.charts.load antes de google.charts.setOnLoadCallback"); retornar b? google.FLVmc.then (b): google. FLVmc}; google.F.load = function (b) {para (var c = [], d = 0; d <argumentos.length; ++ d) c [d-0] = argumentos [d]; d = 0; "visualização" === c [d] && d ++; var e = "atual"; IO (c [d]) && (e = c [d], d ++); var f = {}; c [d]) && (f = c [d]); retorne google.FLVEk (e, f)}; I.pc (q, google.F.load);
google.F.Wj = function (b) {para (var c = [], d = 0; d <argumentos.length; ++ d) c [d-0] = argumentos [d]; if ("visualização" ! == c [0]) Erro de lançamento ('Módulo' '+ c [0] +' "não é suportado. '); google.F.load.apply (google.F, H.Ii (c))} ; google.F.bh = google.FLVpl; I.pc ("google.charts.setOnLoadCallback", google.F.bh); I.ab ("google.load") || (I.pc ("google. load ", google.F.Wj), I.pc (" google.setOnLoadCallback ", google.F.bh));}). call (this);